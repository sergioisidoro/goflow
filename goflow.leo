<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="36" left="128" height="781" width="1183"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sa.20080716081317.2" str_leo_pos="2,1,9"><vh>startup</vh>
<v t="sa.20080714011136.1"><vh>@chapters</vh></v>
<v t="sa.20080716081317.3"><vh>Buttons</vh>
<v t="sa.20080716081317.4"><vh>@button gendocs</vh></v>
<v t="sa.20080720195210.1"><vh>@button clean</vh></v>
</v>
<v t="sa.20080716081317.5"><vh>@settings</vh>
<v t="sa.20080720191846.1"><vh>@strings[vertical,horizontal] initial_splitter_orientation = horizontal</vh></v>
</v>
</v>
<v t="sa.20080726124242.2"><vh>notes</vh></v>
<v t="sa.20080714235246.1" a="E"><vh>src</vh>
<v t="sa.20080724074952.13" a="E"><vh>other workflow engines</vh>
<v t="sa.20080726124242.1"><vh>wfmc</vh>
<v t="sa.20080724074952.15" tnodeList="sa.20080724074952.15,sa.20080724074952.16,sa.20080724074952.17,sa.20080724074952.18,sa.20080724074952.19"><vh>@file attributeintegration.py</vh>
<v t="sa.20080724074952.16"><vh>attributeintegration declarations</vh></v>
<v t="sa.20080724074952.17" a="E"><vh>class AttributeIntegration</vh>
<v t="sa.20080724074952.18"><vh>createParticipant</vh></v>
<v t="sa.20080724074952.19"><vh>createWorkItem</vh></v>
</v>
</v>
<v t="sa.20080724074952.20" tnodeList="sa.20080724074952.20,sa.20080724074952.21,sa.20080724074952.22,sa.20080724074952.23,sa.20080724074952.24,sa.20080724074952.25,sa.20080724074952.26,sa.20080724074952.27,sa.20080724074952.28,sa.20080724074952.29,sa.20080724074952.30,sa.20080724074952.31,sa.20080724074952.32,sa.20080724074952.33,sa.20080724074952.34,sa.20080724074952.35,sa.20080724074952.36,sa.20080724074952.37,sa.20080724074952.38,sa.20080724074952.39,sa.20080724074952.40,sa.20080724074952.41,sa.20080724074952.42,sa.20080724074952.43,sa.20080724074952.44,sa.20080724074952.45,sa.20080724074952.46,sa.20080724074952.47,sa.20080724074952.48,sa.20080724074952.49,sa.20080724074952.50,sa.20080724074952.51"><vh>@file interfaces.py</vh>
<v t="sa.20080724074952.21"><vh>interfaces declarations</vh></v>
<v t="sa.20080724074952.22"><vh>class IIntegration</vh>
<v t="sa.20080724074952.23"><vh>createParticipant</vh></v>
<v t="sa.20080724074952.24"><vh>createWorkItem</vh></v>
</v>
<v t="sa.20080724074952.25"><vh>class IProcessDefinition</vh>
<v t="sa.20080724074952.26"><vh>defineActivities</vh></v>
<v t="sa.20080724074952.27"><vh>defineTransitions</vh></v>
<v t="sa.20080724074952.28"><vh>defineParticipants</vh></v>
<v t="sa.20080724074952.29"><vh>defineApplications</vh></v>
<v t="sa.20080724074952.30"><vh>defineParameters</vh></v>
</v>
<v t="sa.20080724074952.31"><vh>class IActivityDefinition</vh>
<v t="sa.20080724074952.32"><vh>addApplication</vh></v>
<v t="sa.20080724074952.33"><vh>definePerformer</vh></v>
<v t="sa.20080724074952.34"><vh>setAndSplit</vh></v>
<v t="sa.20080724074952.35"><vh>setAndJoin</vh></v>
</v>
<v t="sa.20080724074952.36"><vh>class ITransitionDefinition</vh></v>
<v t="sa.20080724074952.37"><vh>class IProcess</vh></v>
<v t="sa.20080724074952.38"><vh>class IProcessContext</vh>
<v t="sa.20080724074952.39"><vh>processFinished</vh></v>
</v>
<v t="sa.20080724074952.40" a="E"><vh>class IActivity</vh>
<v t="sa.20080724074952.41"><vh>workItemFinished</vh></v>
</v>
<v t="sa.20080724074952.42"><vh>class IApplicationDefinition</vh></v>
<v t="sa.20080724074952.43"><vh>class IParameterDefinition</vh></v>
<v t="sa.20080724074952.44"><vh>class IParticipantDefinition</vh></v>
<v t="sa.20080724074952.45"><vh>class IParticipant</vh></v>
<v t="sa.20080724074952.46"><vh>class IWorkItem</vh>
<v t="sa.20080724074952.47"><vh>start</vh></v>
</v>
<v t="sa.20080724074952.48"><vh>class InvalidProcessDefinition</vh></v>
<v t="sa.20080724074952.49"><vh>class ProcessError</vh></v>
<v t="sa.20080724074952.50"><vh>class IProcessStarted</vh></v>
<v t="sa.20080724074952.51"><vh>class IProcessFinished</vh></v>
</v>
<v t="sa.20080724074952.52" tnodeList="sa.20080724074952.52,sa.20080724074952.53,sa.20080724074952.54,sa.20080724074952.55,sa.20080724074952.56,sa.20080724074952.57,sa.20080724074952.58,sa.20080724074952.59,sa.20080724074952.60,sa.20080724074952.61,sa.20080724074952.62,sa.20080724074952.63,sa.20080724074952.64,sa.20080724074952.65,sa.20080724074952.66,sa.20080724074952.67,sa.20080724074952.68,sa.20080724074952.69,sa.20080724074952.70,sa.20080724074952.71,sa.20080724074952.72,sa.20080724074952.73,sa.20080724074952.74,sa.20080724074952.75,sa.20080724074952.76,sa.20080724074952.77,sa.20080724074952.78,sa.20080724074952.79,sa.20080724074952.80,sa.20080724074952.81,sa.20080724074952.82,sa.20080724074952.83,sa.20080724074952.84,sa.20080724074952.85,sa.20080724074952.86,sa.20080724074952.87,sa.20080724074952.88,sa.20080724074952.89,sa.20080724074952.90,sa.20080724074952.91,sa.20080724074952.92,sa.20080724074952.93,sa.20080724074952.94,sa.20080724074952.95,sa.20080724074952.96,sa.20080724074952.97,sa.20080724074952.98,sa.20080724074952.99,sa.20080724074952.100,sa.20080724074952.101,sa.20080724074952.102,sa.20080724074952.103,sa.20080724074952.104,sa.20080724074952.105,sa.20080724074952.106,sa.20080724074952.107,sa.20080724074952.108,sa.20080724074952.109,sa.20080724074952.110,sa.20080724074952.111,sa.20080724074952.112,sa.20080724074952.113,sa.20080724074952.114,sa.20080724074952.115,sa.20080724074952.116,sa.20080724074952.117,sa.20080724074952.118,sa.20080724074952.119,sa.20080724074952.120,sa.20080724074952.121,sa.20080724074952.122,sa.20080724074952.123,sa.20080724074952.124"><vh>@file process.py</vh>
<v t="sa.20080724074952.53"><vh>process declarations</vh></v>
<v t="sa.20080724074952.54"><vh>always_true</vh></v>
<v t="sa.20080724074952.55"><vh>class TransitionDefinition</vh>
<v t="sa.20080724074952.56"><vh>__init__</vh></v>
<v t="sa.20080724074952.57"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.58"><vh>class ProcessDefinition</vh>
<v t="sa.20080724074952.59"><vh>__init__</vh></v>
<v t="sa.20080724074952.60"><vh>__repr__</vh></v>
<v t="sa.20080724074952.61"><vh>defineActivities</vh></v>
<v t="sa.20080724074952.62"><vh>defineTransitions</vh></v>
<v t="sa.20080724074952.63"><vh>defineApplications</vh></v>
<v t="sa.20080724074952.64"><vh>defineParticipants</vh></v>
<v t="sa.20080724074952.65"><vh>defineParameters</vh></v>
<v t="sa.20080724074952.66"><vh>_start</vh></v>
<v t="sa.20080724074952.67"><vh>__call__</vh></v>
<v t="sa.20080724074952.68"><vh>_dirty</vh></v>
</v>
<v t="sa.20080724074952.69"><vh>class ActivityDefinition</vh>
<v t="sa.20080724074952.70"><vh>__init__</vh></v>
<v t="sa.20080724074952.71"><vh>andSplit</vh></v>
<v t="sa.20080724074952.72"><vh>andJoin</vh></v>
<v t="sa.20080724074952.73"><vh>addApplication</vh></v>
<v t="sa.20080724074952.74"><vh>definePerformer</vh></v>
<v t="sa.20080724074952.75"><vh>addOutgoing</vh></v>
<v t="sa.20080724074952.76"><vh>transitionOutgoing</vh></v>
<v t="sa.20080724074952.77"><vh>computeOutgoing</vh></v>
<v t="sa.20080724074952.78"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.79"><vh>class Process</vh>
<v t="sa.20080724074952.80"><vh>__init__</vh></v>
<v t="sa.20080724074952.81"><vh>definition</vh></v>
<v t="sa.20080724074952.82"><vh>start</vh></v>
<v t="sa.20080724074952.83"><vh>outputs</vh></v>
<v t="sa.20080724074952.84"><vh>_finish</vh></v>
<v t="sa.20080724074952.85"><vh>transition</vh></v>
<v t="sa.20080724074952.86"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.87"><vh>class WorkflowData</vh></v>
<v t="sa.20080724074952.88"><vh>class ProcessStarted</vh>
<v t="sa.20080724074952.89"><vh>__init__</vh></v>
<v t="sa.20080724074952.90"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.91"><vh>class ProcessFinished</vh>
<v t="sa.20080724074952.92"><vh>__init__</vh></v>
<v t="sa.20080724074952.93"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.94"><vh>class Activity</vh>
<v t="sa.20080724074952.95"><vh>__init__</vh></v>
<v t="sa.20080724074952.96"><vh>definition</vh></v>
<v t="sa.20080724074952.97"><vh>start</vh></v>
<v t="sa.20080724074952.98"><vh>workItemFinished</vh></v>
<v t="sa.20080724074952.99"><vh>finish</vh></v>
<v t="sa.20080724074952.100"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.101"><vh>class WorkItemFinished</vh>
<v t="sa.20080724074952.102"><vh>__init__</vh></v>
<v t="sa.20080724074952.103"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.104"><vh>class Transition</vh>
<v t="sa.20080724074952.105"><vh>__init__</vh></v>
<v t="sa.20080724074952.106"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.107"><vh>class ActivityFinished</vh>
<v t="sa.20080724074952.108"><vh>__init__</vh></v>
<v t="sa.20080724074952.109"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.110"><vh>class ActivityStarted</vh>
<v t="sa.20080724074952.111"><vh>__init__</vh></v>
<v t="sa.20080724074952.112"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.113"><vh>class Parameter</vh>
<v t="sa.20080724074952.114"><vh>__init__</vh></v>
</v>
<v t="sa.20080724074952.115"><vh>class OutputParameter</vh></v>
<v t="sa.20080724074952.116"><vh>class InputParameter</vh></v>
<v t="sa.20080724074952.117"><vh>class InputOutputParameter</vh></v>
<v t="sa.20080724074952.118"><vh>class Application</vh>
<v t="sa.20080724074952.119"><vh>__init__</vh></v>
<v t="sa.20080724074952.120"><vh>defineParameters</vh></v>
<v t="sa.20080724074952.121"><vh>__repr__</vh></v>
</v>
<v t="sa.20080724074952.122"><vh>class Participant</vh>
<v t="sa.20080724074952.123"><vh>__init__</vh></v>
<v t="sa.20080724074952.124"><vh>__repr__</vh></v>
</v>
</v>
<v t="sa.20080724074952.125"><vh>@file publication.xpdl</vh></v>
<v t="sa.20080724074952.126"><vh>@file README.txt</vh></v>
<v t="sa.20080724074952.127" tnodeList="sa.20080724074952.127,sa.20080724074952.128,sa.20080724074952.129,sa.20080724074952.130,sa.20080724074952.131,sa.20080724074952.132,sa.20080724074952.133,sa.20080724074952.134,sa.20080724074952.135"><vh>@file tests.py</vh>
<v t="sa.20080724074952.128"><vh>tests declarations</vh></v>
<v t="sa.20080724074952.129"><vh>tearDown</vh></v>
<v t="sa.20080724074952.130"><vh>setUp</vh></v>
<v t="sa.20080724074952.131"><vh>test_multiple_input_parameters</vh></v>
<v t="sa.20080724074952.132"><vh>test_pickling</vh></v>
<v t="sa.20080724074952.133"><vh>test_inputoutput</vh></v>
<v t="sa.20080724074952.134"><vh>test_wrong_number_process_args_error_message</vh></v>
<v t="sa.20080724074952.135"><vh>test_suite</vh></v>
</v>
<v t="sa.20080724074952.136" tnodeList="sa.20080724074952.136,sa.20080724074952.137,sa.20080724074952.138,sa.20080724074952.139,sa.20080724074952.140,sa.20080724074952.141,sa.20080724074952.142,sa.20080724074952.143,sa.20080724074952.144,sa.20080724074952.145,sa.20080724074952.146,sa.20080724074952.147,sa.20080724074952.148,sa.20080724074952.149,sa.20080724074952.150,sa.20080724074952.151,sa.20080724074952.152,sa.20080724074952.153,sa.20080724074952.154,sa.20080724074952.155,sa.20080724074952.156,sa.20080724074952.157,sa.20080724074952.158,sa.20080724074952.159,sa.20080724074952.160,sa.20080724074952.161,sa.20080724074952.162,sa.20080724074952.163,sa.20080724074952.164,sa.20080724074952.165,sa.20080724074952.166,sa.20080724074952.167,sa.20080724074952.168,sa.20080724074952.169,sa.20080724074952.170,sa.20080724074952.171,sa.20080724074952.172,sa.20080724074952.173,sa.20080724074952.174,sa.20080724074952.175,sa.20080724074952.176,sa.20080724074952.177"><vh>@file xpdl.py</vh>
<v t="sa.20080724074952.137"><vh>xpdl declarations</vh></v>
<v t="sa.20080724074952.138"><vh>class HandlerError</vh>
<v t="sa.20080724074952.139"><vh>__init__</vh></v>
<v t="sa.20080724074952.140"><vh>__repr__</vh></v>
<v t="sa.20080724074952.141"><vh>__str__</vh></v>
</v>
<v t="sa.20080724074952.142"><vh>class Package</vh>
<v t="sa.20080724074952.143"><vh>__init__</vh></v>
<v t="sa.20080724074952.144"><vh>defineApplications</vh></v>
<v t="sa.20080724074952.145"><vh>defineParticipants</vh></v>
</v>
<v t="sa.20080724074952.146"><vh>class XPDLHandler</vh>
<v t="sa.20080724074952.147"><vh>__init__</vh></v>
<v t="sa.20080724074952.148"><vh>startElementNS</vh></v>
<v t="sa.20080724074952.149"><vh>endElementNS</vh></v>
<v t="sa.20080724074952.150"><vh>characters</vh></v>
<v t="sa.20080724074952.151"><vh>setDocumentLocator</vh></v>
<v t="sa.20080724074952.152"><vh>Package</vh></v>
<v t="sa.20080724074952.153"><vh>WorkflowProcess</vh></v>
<v t="sa.20080724074952.154"><vh>FormalParameter</vh></v>
<v t="sa.20080724074952.155"><vh>Participant</vh></v>
<v t="sa.20080724074952.156"><vh>Application</vh></v>
<v t="sa.20080724074952.157"><vh>application</vh></v>
<v t="sa.20080724074952.158"><vh>description</vh></v>
<v t="sa.20080724074952.159"><vh>ActivitySet</vh></v>
<v t="sa.20080724074952.160"><vh>Activity</vh></v>
<v t="sa.20080724074952.161"><vh>Tool</vh></v>
<v t="sa.20080724074952.162"><vh>tool</vh></v>
<v t="sa.20080724074952.163"><vh>actualparameter</vh></v>
<v t="sa.20080724074952.164"><vh>performer</vh></v>
<v t="sa.20080724074952.165"><vh>Join</vh></v>
<v t="sa.20080724074952.166"><vh>Split</vh></v>
<v t="sa.20080724074952.167"><vh>TransitionRef</vh></v>
<v t="sa.20080724074952.168"><vh>Transition</vh></v>
<v t="sa.20080724074952.169"><vh>transition</vh></v>
<v t="sa.20080724074952.170"><vh>condition</vh></v>
</v>
<v t="sa.20080724074952.171"><vh>class Tool</vh>
<v t="sa.20080724074952.172"><vh>__init__</vh></v>
</v>
<v t="sa.20080724074952.173"><vh>class TextCondition</vh>
<v t="sa.20080724074952.174"><vh>__init__</vh></v>
<v t="sa.20080724074952.175"><vh>__getstate__</vh></v>
<v t="sa.20080724074952.176"><vh>__call__</vh></v>
</v>
<v t="sa.20080724074952.177"><vh>read</vh></v>
</v>
<v t="sa.20080724074952.178"><vh>@file xpdl.txt</vh></v>
</v>
</v>
<v t="sa.20080714011136.2" a="E"><vh>docs</vh>
<v t="sa.20080714012008.6"><vh>@rst index.rst</vh></v>
<v t="sa.20080714012008.2"><vh>@rst overview.rst</vh>
<v t="sa.20080714081843.1"><vh>Preface</vh></v>
<v t="sa.20080714081843.3"><vh>Summary</vh></v>
<v t="sa.20080714081843.2"><vh>Overview</vh></v>
<v t="sa.20080714081843.4"><vh>Benefits of using GoFlow</vh>
<v t="sa.20080715122316.2"><vh>To User</vh>
<v t="sa.20080714081843.5"><vh>Efficiency</vh></v>
<v t="sa.20080714081843.6"><vh>Formalisation </vh></v>
<v t="sa.20080715122316.3"><vh>Compliance</vh></v>
</v>
<v t="sa.20080715122316.4"><vh>To Developer</vh>
<v t="sa.20080717192016.4"><vh>Extensibility</vh></v>
<v t="sa.20080715122316.9"><vh>Simplicity</vh></v>
<v t="sa.20080715122316.5"><vh>Django Integration</vh></v>
<v t="sa.20080715122316.6"><vh>Python Language</vh></v>
<v t="sa.20080715122316.7"><vh>Web configuration of Workflow</vh></v>
<v t="sa.20080715122316.8"><vh>Speed of Development</vh></v>
</v>
</v>
<v t="sa.20080714081843.7"><vh>The Process Definition</vh>
<v t="sa.20080714081843.8"><vh>Activities (What)</vh></v>
<v t="sa.20080714081843.9"><vh>Transitions (When)</vh></v>
<v t="sa.20080714081843.10"><vh>Applications (How)</vh></v>
<v t="sa.20080714081843.11"><vh>Users &amp; Roles (Who)</vh></v>
</v>
<v t="sa.20080714081843.12"><vh>The Process ProcessInstance</vh>
<v t="sa.20080714081843.13"><vh>Workitems: tracking the history</vh></v>
<v t="sa.20080714081843.14"><vh>Worklist and assigning work</vh></v>
<v t="sa.20080714081843.16"><vh>Exception Handling</vh></v>
<v t="sa.20080714081843.15"><vh>Focus on Flexibility</vh></v>
<v t="sa.20080714081843.17"><vh>Dynamic Redesign</vh></v>
</v>
<v t="sa.20080714081843.18"><vh>Features</vh></v>
<v t="sa.20080714081843.19"><vh>Requirements</vh></v>
<v t="sa.20080714081843.20"><vh>Download</vh></v>
</v>
<v t="sa.20080714012008.9"><vh>@rst install.rst</vh></v>
<v t="sa.20080714012008.5"><vh>@rst tutorials.rst</vh>
<v t="sa.20080714081843.28"><vh>Prerequisites</vh></v>
<v t="sa.20080714081843.29"><vh>Project "Hello World"</vh>
<v t="sa.20080714081843.30"><vh>Let's add an activity</vh></v>
<v t="sa.20080714081843.31"><vh>Let's add our own models</vh></v>
<v t="sa.20080714081843.32"><vh>And for some code</vh></v>
</v>
<v t="sa.20080714081843.33"><vh>Advanced Tutorial</vh>
<v t="sa.20080714081843.34"><vh>Prerequisites</vh></v>
<v t="sa.20080714081843.35"><vh>Application Unit Testing</vh></v>
<v t="sa.20080714081843.36"><vh>Application Automation</vh></v>
</v>
</v>
<v t="sa.20080714012008.42"><vh>@rst patterns.rst</vh>
<v t="sa.20080717192016.13"><vh>Sequence Pattern</vh>
<v t="sa.20080717192016.14"><vh>Description</vh></v>
<v t="sa.20080717192016.15"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.16"><vh>Examples</vh></v>
<v t="sa.20080717192016.17"><vh>Motivation</vh></v>
</v>
<v t="sa.20080717192016.18"><vh>XOR-Join Pattern</vh>
<v t="sa.20080717192016.19"><vh>Description</vh></v>
<v t="sa.20080717192016.20"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.21"><vh>Examples</vh></v>
<v t="sa.20080717192016.22"><vh>Motivation</vh></v>
</v>
<v t="sa.20080717192016.23"><vh>XOR-Split Pattern</vh>
<v t="sa.20080717192016.24"><vh>Description</vh></v>
<v t="sa.20080717192016.25"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.26"><vh>Examples</vh></v>
<v t="sa.20080717192016.27"><vh>Motivation</vh></v>
</v>
<v t="sa.20080714012008.44"><vh>AND-Join Pattern</vh>
<v t="sa.20080717192016.5"><vh>Description</vh></v>
<v t="sa.20080717192016.6"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.7"><vh>Examples</vh></v>
<v t="sa.20080717192016.8"><vh>Motivation</vh></v>
</v>
<v t="sa.20080714012008.45"><vh>AND-Split Pattern</vh>
<v t="sa.20080717192016.9"><vh>Description</vh></v>
<v t="sa.20080717192016.10"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.11"><vh>Examples</vh></v>
<v t="sa.20080717192016.12"><vh>Motivation</vh></v>
</v>
</v>
<v t="sa.20080714012008.3"><vh>@rst faq.rst</vh>
<v t="sa.20080714081843.21"><vh>What is this all about?</vh></v>
<v t="sa.20080714081843.22"><vh>When should I use PushApplication and when should I use Roles in Activity definition? What happens if I select both?</vh></v>
<v t="sa.20080714081843.23"><vh>What are AutoStart and AutoFinish in Activity definition</vh></v>
<v t="sa.20080714081843.25"><vh>How should I define a transition condition ?</vh></v>
<v t="sa.20080714081843.24"><vh>Is it valid to reuse Activities?</vh></v>
</v>
<v t="sa.20080714012008.7"><vh>@rst history.rst</vh>
<v t="sa.20080714081843.37"><vh>Origins</vh></v>
<v t="sa.20080714081843.38"><vh>Roadmap</vh></v>
<v t="sa.20080714081843.39"><vh>Current Status</vh></v>
<v t="sa.20080714081843.40"><vh>Future Features</vh></v>
</v>
<v t="sa.20080714012008.8"><vh>@rst definitions.rst</vh>
<v t="sa.20080715111354.1"><vh>Introduction &amp; Concepts</vh></v>
<v t="sa.20080715111354.2"><vh>Definitions</vh>
<v t="sa.20080715111354.3"><vh>Process</vh></v>
<v t="sa.20080715111354.4"><vh>Activity</vh></v>
<v t="sa.20080715111354.5"><vh>Transitions</vh></v>
<v t="sa.20080715111354.6"><vh>Role</vh></v>
<v t="sa.20080715111354.7"><vh>ProcessInstance</vh></v>
<v t="sa.20080715111354.8"><vh>WorkItem</vh></v>
</v>
<v t="sa.20080715111354.9"><vh>Activity Types</vh>
<v t="sa.20080715111354.10"><vh>Start Activity</vh></v>
<v t="sa.20080715111354.11"><vh>End Activity</vh></v>
<v t="sa.20080715111354.12"><vh>Normal Activity</vh></v>
<v t="sa.20080715111354.13"><vh>Switch Activity</vh></v>
<v t="sa.20080715111354.14"><vh>Split Activity</vh></v>
<v t="sa.20080715111354.15"><vh>Join Activity</vh></v>
<v t="sa.20080715111354.16"><vh>Standalone Activity</vh></v>
</v>
<v t="sa.20080715111354.17"><vh>AutoRouting &amp; Interactiveness</vh>
<v t="sa.20080715111354.18"><vh>AutoRouting</vh></v>
<v t="sa.20080715111354.19"><vh>Interactiveness</vh></v>
</v>
<v t="sa.20080715111354.20"><vh>Sample Process</vh></v>
<v t="sa.20080715111354.21"><vh>Modules</vh>
<v t="sa.20080715111354.22"><vh>Process Manager</vh></v>
<v t="sa.20080715111354.23"><vh>User Interface</vh></v>
<v t="sa.20080715111354.24"><vh>The Process Monitor</vh></v>
</v>
</v>
<v t="sa.20080714012008.11"><vh>@rst changes.rst</vh>
<v t="sa.20080714225902.5" a="E"><vh>Version 0.6 (refactored branch)</vh>
<v t="sa.20080714225902.6" a="E"><vh>New Features</vh>
<v t="sa.20080724074952.3"><vh>Improved API</vh></v>
<v t="sa.20080724074952.11"><vh>Improvement documentation system</vh></v>
<v t="sa.20080727142922.1"><vh>restructuring</vh></v>
<v t="sa.20080724074952.12"><vh>Improved Logging Machinery</vh></v>
</v>
<v t="sa.20080714225902.7"><vh>Bug Fixes</vh></v>
<v t="sa.20080714225902.8"><vh>Backwards Incompatible Changes</vh></v>
</v>
<v t="sa.20080720192331.1"><vh>Version 0.51</vh>
<v t="sa.20080720192331.2"><vh>New Features</vh></v>
<v t="sa.20080720192331.3"><vh>Bug Fixes</vh></v>
<v t="sa.20080720192331.4"><vh>Backwards Incompatible Changes</vh></v>
</v>
</v>
<v t="sa.20080724074952.1"><vh>@rst todo.rst</vh>
<v t="sa.20080724074952.2" a="E"><vh>Version 0.6 (refactored branch)</vh>
<v t="sa.20080724074952.10"><vh>Minimize / Manager Eval</vh></v>
</v>
</v>
<v t="sa.20080714012008.1"><vh>@rst glossary.rst</vh>
<v t="sa.20080715122316.10"><vh>Application</vh></v>
<v t="sa.20080715122316.11"><vh>PushApplication</vh></v>
<v t="sa.20080715122316.12"><vh>User</vh></v>
<v t="sa.20080715111354.4"><vh>Activity</vh></v>
<v t="sa.20080715111354.6"><vh>Role</vh></v>
<v t="sa.20080714081843.26"><vh>Activity-based Workflow</vh></v>
<v t="sa.20080715111354.3"><vh>Process</vh></v>
<v t="sa.20080715111354.5"><vh>Transitions</vh></v>
<v t="sa.20080715111354.25"><vh>Workflow</vh></v>
<v t="sa.20080715111354.7"><vh>ProcessInstance</vh></v>
<v t="sa.20080715111354.8"><vh>WorkItem</vh></v>
</v>
<v t="sa.20080715012904.1"><vh>@rst credits.rst</vh></v>
<v t="sa.20080715012904.2"><vh>@rst license.rst</vh></v>
<v t="sa.20080714012008.12"><vh>modules</vh>
<v t="sa.20080714012008.13"><vh>gen_modules.py</vh>
<v t="sa.20080714012008.14"><vh>gen_modules declarations</vh></v>
<v t="sa.20080714012008.15"><vh>main</vh></v>
</v>
<v t="sa.20080714012008.41"><vh>@rst index.rst</vh></v>
<v t="sa.20080714012008.30"><vh>@rst goflow.rst</vh></v>
<v t="sa.20080714012008.27"><vh>@rst goflow.urls.rst</vh></v>
<v t="sa.20080714012008.28"><vh>@rst goflow.urls_admin.rst</vh></v>
<v t="sa.20080714012008.17"><vh>@rst goflow.graphics.rst</vh></v>
<v t="sa.20080714012008.16"><vh>@rst goflow.graphics.models.rst</vh></v>
<v t="sa.20080714012008.19"><vh>@rst goflow.graphics.views.rst</vh></v>
<v t="sa.20080714012008.18"><vh>@rst goflow.graphics.urls_admin.rst</vh></v>
<v t="sa.20080714012008.21"><vh>@rst goflow.utils.rst</vh></v>
<v t="sa.20080714012008.20"><vh>@rst goflow.utils.logger.rst</vh></v>
<v t="sa.20080714012008.33"><vh>@rst goflow.utils.decorators.rst</vh></v>
<v t="sa.20080714012008.26"><vh>@rst goflow.instances.rst</vh></v>
<v t="sa.20080714012008.23"><vh>@rst goflow.instances.api.rst</vh></v>
<v t="sa.20080714012008.24"><vh>@rst goflow.instances.forms.rst</vh></v>
<v t="sa.20080714012008.25"><vh>@rst goflow.instances.models.rst</vh></v>
<v t="sa.20080727144116.1"><vh>@rst goflow.instances.managers.rst</vh></v>
<v t="sa.20080714012008.29"><vh>@rst goflow.instances.views.rst</vh></v>
<v t="sa.20080714012008.39"><vh>@rst goflow.workflow.rst</vh></v>
<v t="sa.20080714012008.31"><vh>@rst goflow.workflow.managers.rst</vh></v>
<v t="sa.20080714012008.32"><vh>@rst goflow.workflow.applications.rst</vh></v>
<v t="sa.20080714012008.34"><vh>@rst goflow.workflow.forms.rst</vh></v>
<v t="sa.20080714012008.36"><vh>@rst goflow.workflow.models.rst</vh></v>
<v t="sa.20080714012008.37"><vh>@rst goflow.workflow.notification.rst</vh></v>
<v t="sa.20080714012008.38"><vh>@rst goflow.workflow.pushapps.rst</vh></v>
<v t="sa.20080714012008.40"><vh>@rst goflow.workflow.views.rst</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sa.20080714011136.1"></t>
<t tx="sa.20080714011136.2">@ @rst-options
default_path=docs/source
write_intermediate_file=True
show_headlines=True
@c

@language rest
</t>
<t tx="sa.20080714012008.1">.. _glossary:

=========
Glossary
=========


..  glossary:: 


</t>
<t tx="sa.20080714012008.2">.. _overview:

============
Overview
============
</t>
<t tx="sa.20080714012008.3">
.. _faq:


============
GoFlow FAQ
============







</t>
<t tx="sa.20080714012008.5">
.. _tutorial:

==================
GoFlow User Guide
==================

GoFlow is a `django component` which adds activity-based workflow features to a django project.

We'll learn here how to use this module, starting with a very simple "Hello world" django project, and then gradually add features as we go along.
</t>
<t tx="sa.20080714012008.6">=====================
GoFlow Documentation
=====================

Contents
==========

.. toctree::
   :maxdepth: 2

   overview.rst
   tutorials.rst
   patterns.rst

   install.rst
   faq.rst
   todo.rst
   changes.rst
   history.rst
   license.rst
   credits.rst
   definitions.rst

   modules/index.rst
   glossary.rst
   

Indices and tables
===================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
</t>
<t tx="sa.20080714012008.7">
.. _history:

========
History
========







</t>
<t tx="sa.20080714012008.8">
.. _definitions:

==========================
Definitions
==========================









</t>
<t tx="sa.20080714012008.9">.. _install:

==================
Installation
==================

    
Python
-------
      
Depending on your platform you can install python from http://www.python.org and version 2.5.2 is the version that we are using here.
      

Django
-------
   
Try to get the latest subversion trunk version of django from http://www.djangoproject.com
    
    
GoFlow
-------

Latest Release: 
    
    * All releases are available here: http://code.google.com/p/goflow/downloads/list
    
Subversion trunk code::
    
    svn checkout http://goflow.googlecode.com/svn/trunk/ goflow-src
    

  
Optional (but useful) Modules      
-------------------------------

    * Graphviz
    * PIL  
    * Pyyaml
    * Pygraphviz

</t>
<t tx="sa.20080714012008.11">.. _changes:

==========================
Changes
==========================


.. contents::




</t>
<t tx="sa.20080714012008.12">@ @rst-options
default_path=docs/source/modules
@c</t>
<t tx="sa.20080714012008.13">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    main()

</t>
<t tx="sa.20080714012008.14">import sys, os
from Cheetah.Template import Template

template ='''
.. _${mod.name}:

:mod:`${mod.name}` -- ${mod.synopsis} 
================================================================================

.. automodule:: ${mod.name} 
   :synopsis: ${mod.synopsis}

'''

template_ ='''
.. _${mod.name}:

:mod:`${mod.name}` -- ${mod.synopsis} 
================================================================================

..  automodule:: ${mod.name} 
    :members:
    :undoc-members:
    :inherited-members:
'''

lst = [
    ("goflow.rst","primary module containing other goflow submodules."),
    ("goflow.graphics.rst","early goflow graphics module"),
    ("goflow.graphics.models.rst","datamodels for graphics processing"),
    ("goflow.graphics.views.rst","goflow graphics views"),
    ("goflow.graphics.urls_admin.rst","goflow graphics custom admin interface"),
    ("goflow.instances.rst","goflow runtime"),
    ("goflow.instances.api.rst","goflow runtime api"),
    ("goflow.instances.forms.rst","goflow runtime forms"),
    ("goflow.instances.models.rst","goflow runtime models"),
    ("goflow.instances.views.rst","goflow runtime views"),
    ("goflow.instances.urls.rst","goflow runtime urls"),
    ("goflow.instances.urls_admin.rst","goflow runtime custom admin interface"),
    ("goflow.workflow.rst","goflow core workflow functionality"),
    ("goflow.workflow.managers.rst","key model managers for workflow management"),
    ("goflow.workflow.applications.rst","key application function for workflow mgmt"),
    ("goflow.utils.decorators.rst","goflow decorator library"),
    ("goflow.workflow.forms.rst","goflow form utility functions"),
    ("goflow.workflow.logger.rst","logging capability"),
    ("goflow.workflow.models.rst","workflow models"),
    ("goflow.workflow.notification.rst","workflow notification library"),
    ("goflow.workflow.pushapps.rst","example goflow pushapps"),
    ("goflow.workflow.views.rst","views for goflow worklow module"),
]


</t>
<t tx="sa.20080714012008.15">def main():
    results=[]
    for fname, synopsis in lst:
        mod = dict(name=fname[:-4], file=fname, synopsis=synopsis)
        out = file(fname, 'w')
        out.write(str(Template(template, searchList=[dict(mod=mod)])))
        out.close()

    


</t>
<t tx="sa.20080714012008.16">

.. _goflow.graphics.models:

:mod:`goflow.graphics.models` -- datamodels for graphics processing 
================================================================================

.. automodule:: goflow.graphics.models 
   :synopsis: datamodels for graphics processing
   :members:
</t>
<t tx="sa.20080714012008.17">

.. _goflow.graphics:

:mod:`goflow.graphics` -- early goflow graphics module 
================================================================================

.. automodule:: goflow.graphics 
   :synopsis: early goflow graphics module
   :members:
</t>
<t tx="sa.20080714012008.18">

.. _goflow.graphics.urls_admin:

:mod:`goflow.graphics.urls_admin` -- goflow graphics custom admin interface 
================================================================================

.. automodule:: goflow.graphics.urls_admin 
   :synopsis: goflow graphics custom admin interface
   :members:
</t>
<t tx="sa.20080714012008.19">

.. _goflow.graphics.views:

:mod:`goflow.graphics.views` -- goflow graphics views 
================================================================================

.. automodule:: goflow.graphics.views 
   :synopsis: goflow graphics views
   :members:
</t>
<t tx="sa.20080714012008.20">

.. _goflow.utils.logger.:

:mod:`goflow.utils.logger.` -- manages sitewide logging  
================================================================================

.. automodule:: goflow.utils.logger 
   :synopsis: manages sitewide logging  
   :members:
</t>
<t tx="sa.20080714012008.21">

.. _goflow.utils:

:mod:`goflow.utils` -- package for common functionality
================================================================================

.. automodule:: goflow.utils 
   :synopsis: package for common functionality
   :members:
</t>
<t tx="sa.20080714012008.23">

.. _goflow.instances.api:

:mod:`goflow.instances.api` -- goflow runtime api 
================================================================================

.. automodule:: goflow.instances.api 
   :synopsis: goflow runtime api
   :members:

</t>
<t tx="sa.20080714012008.24">

.. _goflow.instances.forms:

:mod:`goflow.instances.forms` -- goflow runtime forms 
================================================================================

.. automodule:: goflow.instances.forms 
   :synopsis: goflow runtime forms
   :members:
</t>
<t tx="sa.20080714012008.25">

.. _goflow.instances.models:

:mod:`goflow.instances.models` -- goflow runtime models 
================================================================================

.. automodule:: goflow.instances.models 
   :synopsis: goflow runtime models
   :members:
</t>
<t tx="sa.20080714012008.26">

.. _goflow.instances:

:mod:`goflow.instances` -- goflow runtime 
================================================================================

.. automodule:: goflow.instances 
   :synopsis: goflow runtime
   :members:
</t>
<t tx="sa.20080714012008.27">

.. _goflow.urls:

:mod:`goflow.urls` -- goflow runtime urls 
================================================================================

.. automodule:: goflow.urls 
   :synopsis: goflow runtime urls
   :members:
</t>
<t tx="sa.20080714012008.28">

.. _goflow.urls_admin:

:mod:`goflow.urls_admin` -- goflow runtime custom admin interface 
================================================================================

.. automodule:: goflow.urls_admin 
   :synopsis: goflow runtime custom admin interface
   :members:
</t>
<t tx="sa.20080714012008.29">

.. _goflow.instances.views:

:mod:`goflow.instances.views` -- goflow runtime views 
================================================================================

.. automodule:: goflow.instances.views 
   :synopsis: goflow runtime views
   :members:
</t>
<t tx="sa.20080714012008.30">

.. _goflow:

:mod:`goflow` -- primary module containing other goflow submodules. 
================================================================================

.. automodule:: goflow 
   :synopsis: primary module containing other goflow submodules.
   :members:
   

</t>
<t tx="sa.20080714012008.31">

.. _goflow.workflow.managers:

:mod:`goflow.workflow.managers` -- key functions for workflow management 
================================================================================

.. automodule:: goflow.workflow.managers 
   :synopsis: key functions for workflow management
   :members:

</t>
<t tx="sa.20080714012008.32">

.. _goflow.workflow.applications:

:mod:`goflow.workflow.applications` -- key application function for workflow mgmt 
==================================================================================

.. automodule:: goflow.workflow.applications 
   :synopsis: key application function for workflow mgmt


.. function:: format_exception(etype, value, tb[, limit=None])

   Format the exception with a traceback.

   :param object: exception type
   :param value: exception value
   :param tb: traceback object
   :param limit: maximum number of stack frames to show
   :type limit: integer or None
   :rtype: list of strings</t>
<t tx="sa.20080714012008.33">

.. _goflow.utils.decorators:

:mod:`goflow.utils.decorators` -- goflow decorator library 
================================================================================

.. automodule:: goflow.utils.decorators 
   :synopsis: goflow decorator library
   :members:
</t>
<t tx="sa.20080714012008.34">

.. _goflow.workflow.forms:

:mod:`goflow.workflow.forms` -- goflow form utility functions 
================================================================================

.. automodule:: goflow.workflow.forms 
   :synopsis: goflow form utility functions
   :members:
</t>
<t tx="sa.20080714012008.36">

.. _goflow.workflow.models:

:mod:`goflow.workflow.models` -- workflow models 
================================================================================

.. automodule:: goflow.workflow.models 
   :synopsis: workflow models
   :members:
</t>
<t tx="sa.20080714012008.37">

.. _goflow.workflow.notification:

:mod:`goflow.workflow.notification` -- workflow notification library 
================================================================================

.. automodule:: goflow.workflow.notification 
   :synopsis: workflow notification library
   :members:
</t>
<t tx="sa.20080714012008.38">

.. _goflow.workflow.pushapps:

:mod:`goflow.workflow.pushapps` -- example goflow pushapps 
================================================================================

.. automodule:: goflow.workflow.pushapps 
   :synopsis: example goflow pushapps
   :members:
</t>
<t tx="sa.20080714012008.39">

.. _goflow.workflow:

:mod:`goflow.workflow` -- goflow core workflow functionality 
================================================================================

.. automodule:: goflow.workflow 
   :synopsis: goflow core workflow functionality
   :members:
</t>
<t tx="sa.20080714012008.40">

.. _goflow.workflow.views:

:mod:`goflow.workflow.views` -- views for goflow worklow module 
================================================================================

.. automodule:: goflow.workflow.views 
   :synopsis: views for goflow worklow module
   :members:
</t>
<t tx="sa.20080714012008.41">
=====================
GoFlow Modules
=====================

.. contents::

goflow
==========

.. toctree::
   :maxdepth: 2

   goflow.rst
   goflow.urls.rst
   goflow.urls_admin.rst

goflow.graphics
-----------------

.. toctree::
   :maxdepth: 2

   goflow.graphics.rst
   goflow.graphics.models.rst
   goflow.graphics.views.rst
   goflow.graphics.urls_admin.rst


goflow.instances
-----------------

.. toctree::
   :maxdepth: 2
      
   goflow.instances.rst
   goflow.instances.api.rst
   goflow.instances.managers.rst   
   goflow.instances.forms.rst
   goflow.instances.models.rst
   goflow.instances.views.rst


goflow.workflow
-----------------

.. toctree::
   :maxdepth: 2

   goflow.workflow.rst
   goflow.workflow.managers.rst
   goflow.workflow.applications.rst
   goflow.workflow.forms.rst
   goflow.workflow.models.rst
   goflow.workflow.notification.rst
   goflow.workflow.pushapps.rst
   goflow.workflow.views.rst

goflow.utils
-----------------

.. toctree::
   :maxdepth: 2

   goflow.utils.rst
   goflow.utils.decorators.rst
   goflow.utils.logger.rst

Indices and tables
===================
* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
</t>
<t tx="sa.20080714012008.42">.. _patterns:

====================
Workflow Patterns
====================

    * Sequence:
        An ActivityInstance is enabled after another ActivityInstance
        in the same ProcessInstance has completed.

    * Parallel Split (AND-Split):
        A point in the ProcessInstance where it splits into several, 
        parallel running ActivityInstances.

    * Exclusive Choice (XOR-Split):
        A point in the Process where ONE of n Transitions evaluates true 
        and creates ONE new ActivityInstance (first-come-first-serve).

    * Synchronisation (AND-Join):
        A point in the ProcessInstance? that needs to wait for all incoming
        Transitions from previous ActivityInstances and then processes
        further.

    * Simple Join (XOR-Join):
        A point in the ProcessInstance that waits for one incoming 
        Transition from an ActivityInstance and then processes further.

    * Loop:
        Repeat a certain sequence of Activities until a condition 
        evaluates true
</t>
<t tx="sa.20080714012008.44">

..  image:: images/and-join.png
    :align: center

</t>
<t tx="sa.20080714012008.45">

..  image:: images/and-split.png
    :align: center

</t>
<t tx="sa.20080714081843.1">This document presents an introduction to "GoFlow", a workflow engine for django. 

The manual has been generated from reStructuredText source markup with
Sphinx, which should make it much easier to keep it up-to-date in the
future.

</t>
<t tx="sa.20080714081843.2">GoFlow is an activity based workflow management system that is designed as django component.

Being activity based means that the processes, the workflows, are made of activities to be completed in order to get something done. This differs from entity based workflows where the focus is set on a given document and the states it has to go through in order to be completed.

For example, the process describing a research in your campus library can be handled as an activity based process: you have to get a signed authorization by your teacher, go find your books of interest using either the computer catalogs or the librarian's help, and then check-out the books you need (signing the appropriate stuff). This is a list of activities to be carried out in order to get some books out of the library.
There is no main document in this process.

Another example of an activity based process might be represented by the fund request submission process. A teacher of the university has to submit a request for buying a new computer. The process starts by filling in a form where the teacher specifies what he intends to buy and how much this costs. The form will be handled by the administration office and, if the total cost goes beyond a given threshold, it requires the personal authorization by the administration chief. Budget is then checked to see if the teacher has appropriate funds left for the acquisition. In the end an e-mail is sent to the teacher telling him the result of the submission; the request is filed in the request archive and the funding database is updated subtracting the requested cost from the available money left. This process has a main document (the request) but it has a lot of side actions to be carried out as well: signed authorization, archive insertion, database update, e-mail sending. The best way to describe this is through an activity based workflow, where the process is made of activities to be carried out.

On the other hand simpler processes do not require the complex structure of an actvity based workflow management system, and a simple entity-based workflow would suffice. For example the publication of documents on a web site can be simply modelled by the given document going through the states of new, submitted, and then approved or rejected. In such workflows the document is the main issue, and its available actions are defined by its current state.</t>
<t tx="sa.20080714081843.3">The main purpose of a workflow management system is to address the problem of "who must do what, when and how". 

In an activity based workflow management system (such as GoFlow) this problem finds a solution.

To this end, GoFlow provides a number of key functional elements:

    * The **Process** defining the sequence of activities to be carried out says what should be done and when by the definition of activities and transitions. 

    * An **Activity** (the *what* part of the workflow) represents something to be done: giving authorization, updating a database, sending an e-mail, loading a truck, filling a form, printing a document and so on. 
    
    * A **Transition** defines the appropriate sequence of activities for a process (the *when* part of the issue).

    * Each activity will have an associated **Application** designed to carry out the job: the *how* part. 
    
    * The *who* part is generally the **User** assigned to carry out the activity, through its application. Usually activity applications will be used by someone, a person, but in many cases the entity assigned to an activity might be an automatic system. Afterall, why should you have a person waste time updating a database if it can be done in software directly?

</t>
<t tx="sa.20080714081843.4"></t>
<t tx="sa.20080714081843.5">One reason to use a workflow management system is to improve the efficiency and performance of the processes you usually handle. A lot of activities you usually do can actually be carried out by an automatic system. Database update, e-mail sending, research, document archiving and so on are activities that a computer can carry out with no need for human intervention. This means that the activity job will be completed much faster and the human resources can be used in some more valuable way (and they will be grateful for that).</t>
<t tx="sa.20080714081843.6">Another reason to use a workflow management system is to always have the answer to the question "who must do what, when and how". Formalizing your process means wasting no time in deciding what to do, having each person performing the right job and being sure that your process can be completed appropriately.</t>
<t tx="sa.20080714081843.7">The goal of a process definition is to give answer the question "who must do what, when and how".

Activities and transitions describe the process you want to model (the what and when part). You can see them as the "bubbles and arrows" description of what has to be done and when. 

Applications describe the how part and are associated with activities. Users and roles describe the who part.</t>
<t tx="sa.20080714081843.8">Each activity can be of three different kinds: application, sub-process or routing. Usually each activity of the process definition describes something that has do be done, some kind of work. This work can be either carried out by an application or by a sub process definition that better refines the job to be done.

Sometimes an activity will be assigned the simple job of handling the routing of work in the process. In this case the activity is just a dummy activity that simply chooses what to do next.

Each activity has one incoming guard for collecting incoming transitions that lead to it. The activity incoming guard can be either set to and or xor for two different behaviour:

    * and: means that all the activities that lead to this activity have to be
      completed in order to enable this activity to work.

    * xor: means that just one of the activities that lead to this activity has to be 
      completed in order to enable this activity to work.

Each activity also has one outgoing guard for collecting outgoing transitions getting out of it. Again, the activity outgoing guard can be either set to and or xor for two different behaviours:

    * and: means that this activity will trigger the work of all the activities it   
      connects to; doing this the flow in the process will be split in parallel 
      (concurrent) flows.

    * xor: means that this activity will trigger the work of just one of the 
      activities it connects to, depending on condition evaluation (see transitions 
      below).
    
Work performed by an activity will be triggered in different ways as determined by the start mode setting of the activity itself. It can be set to either:

    * automatic: the activity will run its application as soon as an instance 
      workitem reaches it. There will be no worklist for users: it will be openflow 
      itself taking care of starting the activity application on the workitem.

    * manual: openflow will wait for user intervention to start the activity 
      application: usually this is done through the call to the "callApplication" API 
      of workflow. This worklist the user is using (like the default worklist in 
      openflow does).

When an application completes its job the activity finish mode will be evaluated. It can be set to either:

    * automatic: as soon as a "completeWorkitem" api is called (supposedly by the activity
      application upon ending its work) the instance will be automatically 
      finish mode this will not be done, and user (again, the activity application upon 
      have to call the "forwardWorkitem" api. This enables the user to choose a given path  
      (transition) for the instance to follow. So mainly this mode is reserved for manually 
      steering the instance in alternative paths of the process. (Remember that you can 
      automatically steer the instance giving condition to transitions: see below).
</t>
<t tx="sa.20080714081843.9">Transitions connect activities together. A transition connecting activity A with activity B states that as soon as A is finished B has to be started.

Transitions can be guarded by conditions. A transition condition will be evaluated if the "from" activity has choose one and only one path to be followed (ie: the activity has an xor outgoing guard).</t>
<t tx="sa.20080714081843.10">An application is assigned to each activity in order to carry out the job the activity has to do. 

Applications can be anything triggered by an url call: python scripts, dtml forms, sql queries, Zope applications or even external applications like word or other custom and dedicated applications.

What the application is required to do is to invoke the appropriate api for interacting with GoFlow. For example the application will need to invoke the Openflow completeWorkitem to signal Openflow that its job is finished and a new activity can be started.</t>
<t tx="sa.20080714081843.11">Users are assigned to applications through roles.

The available roles for openflow are the django-defined roles. To add a role just add a group role to the folder where you build your application.

One user can be listed in one or more roles. Roles can list one or more activities. Each user will be able to work on all activities listed in roles he is listed in.

Actually each role will keep three different lists:

    * users list: list of users assigned to the role
    
    * enabled activities: list of process activities that users listed in this role can 
      work on
    
    * assignable activities: list of process activities that users listed in this 
      role can assign to other users</t>
<t tx="sa.20080714081843.12">A process definition gives the instructions for completing some work. A process instance, in turn, is an actual execution of a process definition.

For example, if the process definition describes what should be done for submitting a fund request, a process instance of that process definition is an actual submission for funding.</t>
<t tx="sa.20080714081843.13">We call workitem the execution of a single activity of the process definition. Workitems are created every time an activity is triggered. Workitems are never destroyed, even when an activity completes its job, the workitem created to represent the execution of that activity is just set to a complete state. A process instance is a collection of workitems: one per activity executed (or in execution).

One of the most important jobs of a workitem is to keep track of events during the execution of its activity. Since the process instance keeps track of all its workitems, and each workitem keeps track of all the events that happen during the execution of the activity, the complete history of everyting that has happened is recorded in each process instance.

This is very useful for two reasons:
    
    * you can have access to an event log of every single instance begun in your process
    
    * you can learn from analysis of these reports how to better design your process,
      considering load balancing, completion times, and so on.</t>
<t tx="sa.20080714081843.14">To each user is associated a worklist: a list of workitems pending on activities the user is supposed to perform. The worklist is not set to a given size: it grows when activities require additional work to be done, and it shrinks as the work on activities is completed.

Users are presented their worklists to let them know what is to be done. In Openflow three policies exist for work assignment: pull, manual push and automatic push.

* pull policy means that users will choose what to do, as if the work to be done was gathered in a common pool where users go fetch what they want to take care of

* manual push policy means the user is assigned work by another user

* automatic push policy means the user is automatically assigned work by the engine itself

You can see this as having the process instance workitems assigned to users: pulling will be self assignment and pushing will be assignment by somebody else (or by the engine itself).

Whichever policy is used for assigning work, once a user is assigned some work he will be the only one enabled to carry it out: Other users will not see the assigned work in their worklist.
</t>
<t tx="sa.20080714081843.15">In existing workflow management systems flexibility is a major issue. When you design a process definition there is variable (and usually low) chance the process you defined is actually the most appropriate model you could get of the process.

It is very important to have a way to handle cases that go outside of the set boundary, the "exceptions". At the same time it is also important to have tools that let you change the process definition even while it is running: it can be dramatic having to stop your processes to change their definitions.

</t>
<t tx="sa.20080714081843.16">Exception handling is necessary for unforeseen situations when users have to handle something that the process was not designed to handle.

Instead of a normal handling of a workitem the user can make it "fall out" of the normal process flow. The fallen (exceptional) token will then be available to any user assigned to handle exceptions. As soon as the workitem is fixed, it can be inserted into any activity of the process to resume the process flow. In this way the user can change the workitem data anyway he wants, to adjust to the exceptional situation.

</t>
<t tx="sa.20080714081843.17">A process definition can be changed while in execution (while process instances run the flow). New activities can be added, old ones deleted, transition created or changed and so on. Any invalidating situation that might occur will be handled, causing the appropriate workitem to fall out (go into exceptional state).

As soon as the process is changed all the current process instances will read the new process definition as the definition to be used.

Dynamic redesign and exception handling are related to each other. Exception handling allows for dealing with unforeseen events: it should suggest changes in the process definition to handle that situation in the future. On the other hand dynamic redesign will probably put some (or all) process instances into an invalid state: exception handling should be used to recover from these situations.</t>
<t tx="sa.20080714081843.18"></t>
<t tx="sa.20080714081843.19"></t>
<t tx="sa.20080714081843.20"></t>
<t tx="sa.20080714081843.21">To understand what is ``activity based workflow`` take a look at `OpenFlow`_ 

.. _OpenFlow: http://www.openflow.it/Documentation/documentation/OpenFlowIntroduction
</t>
<t tx="sa.20080714081843.22">When an Activity is activated (automatically or manually by calling activate API method) it is assigned to the User that is returned by PushApplication. If there is no PushApplication then Activity is assigned to selected Roles. If you choose both, then only PushApplication is used.</t>
<t tx="sa.20080714081843.23">AutoStart and AutoFinish are start mode and finish mode as described here: http://www.openflow.it/Documentation/documentation/OpenFlowIntroduction For example if AutoStart is not checked, then to start Activity it is necessary to call activate API function on it. If AutoStart is checked, then it is automatically activated as soon as previous activities are finished (depending on guard condition: xor, and) </t>
<t tx="sa.20080714081843.24">The good practise is to reuse Applications, not Activities: Applications should be reused because they take time to build; Activities are just containers for applications, with some parameters to fit the process needs.

You can customize application with parameters:

    * at global level, in urls.py files
    * at process level, in activities (application parameters field)

</t>
<t tx="sa.20080714081843.25">transitions have a condition attribute: it is a python expression that returns a boolean. the variables that can be used in the boolean expression are instance and workitem. examples:

    * OK: the user has pushed the OK button
    * instance.condition == "OK": the user has pushed the OK button
    * workitem.timeout(delay=5, unit='days'): the task is waiting for 5 days or more (NYI but soon)</t>
<t tx="sa.20080714081843.26">
An activity-based workflow is a workflow that is centered around a set of activities that someone (or something) has to do.

A given process instance (an instance of a process definition) may have several active workitems, which are the "pending" work a given actor has to do. Once a workitem is completed, the process definition specifies what are the next activities, and thus what new workitems must be created.

The main concepts in the definition of a process for an activity-based workflow are:

    * activities
        * applications that describe work
        * sub-process that recursively describe another process
    * transitions, with guards, deciding what's next</t>
<t tx="sa.20080714081843.28">Prerequisite
=================
Create a directory, and copy the directory ``goflow`` to this directory (you can also place it in any directory in your PYTHONPATH).

.. note::
   While the Django documentation advocates the use of absolute paths, the use of relative paths
   in what follows is voluntary. This is done in order to simplify expressions and to be platform 
   independent (and it works, at least under Windows and OS X)</t>
<t tx="sa.20080714081843.29">Project "Hello World"
======================
We will discover the workflow engine with a very simple application based on a process workflow with a single activity (a single activity, with no transitions: the simplest possible workflow). The purpose of this activity is to receive a message (for example, "Hello world").

    * Start by creating an empty django project (or use an existing project)::

        Django admin-startproj myproj

    * Add the following applications in the file ``settings.py``::

        INSTALLED_APPS = (
         ...
         'django.contrib.admin'
         'goflow.workflow'
         'goflow.instances'
        )

The `workflow` application contains the "static" model data (modeling
process), and the ``instances`` application contains the dynamic part or runtime.

    * Set up the database part of the settings file, for example like this::

        DATABASE_ENGINE = 'sqlite3'
        DATABASE_NAME = 'data.sqlite'

    * Add the following two lines in the ``urls.py``  file::

        urlpatterns = patterns (``,
         ...

         # Uncomment this for admin:
         (r '^ admin /', include ( 'django.contrib.admin.urls')),
         (r '^ workflow /', include ( 'goflow.urls')),
        )


    * Now create the database server and start it as follows::

        python manage.py syncdb - pythonpath =..
        python manage.py runserver - pythonpath =..


We can now open the console admin [http://localhost:8000/admin], and discover the data models introduced by GoFlow:

..  image:: images/admin1.png
    :align: center

We can also discover the GoFlow Dashboard, which provide easy access to the status of workflows using a "back-office" perspective, [http://localhost:8000/workflow]

..  image:: images/admin2.png
    :align: center

We will now create a process workflow.

Return to the admin console, add an entity Process as shown with the screen below:

..  image:: images/admin4.png
    :align: center

Use "Hello world" for the title, and optionally provide a description of the new process

    * Register using the ``Save button and continue editing``: you can now see that an 
      activity ``End`` was added automatically.

    * Create an initial activity by clicking on the icon "+" in the field ``Initial activity``: 
      enter a title, set the process dropdown to the current process "Hello world", leaving the 
      default values for other fields.

    * Save

We have created our first process workflow:

..  image:: images/admin4.png
    :align: center

You may observe that we have not yet specified an application (a url with underlying functionality e.g. views/templates/classes/functions/modules etc..) for our business, and we will shortly see that this is not necessary to begin to "play" with our application.

Indeed, when an activity is not associated with an application, a special testing application is still invoked to simulate this activity: providing a panel to the user, displaying the name, description of the activity, and also a history of the workflow, with an ``OK`` button allowing you to complete the activity.

Before we start running our process workflow, we must first create a ``Group`` with a single permission to allow users to instantiate it:

    * Add a group named ``Hello world``, give it the permission ``can_instantiate`` on the  
      content type ``workflow.process``, and save. (note: the name of the group and the name of 
      the process must be the same)
      
    * Add this group to the current user: this will allow the user to instantiate the process 
      ``Hello world``.

We are now ready to execute/test the workflow: go to the dashboard [http://localhost:8000/workflow]. You will find the process and its definition, and other information on roles and permissions.

    * Click on the link ``start a simulation instance`` under the process ``Hello world``
</t>
<t tx="sa.20080714081843.30"></t>
<t tx="sa.20080714081843.31"></t>
<t tx="sa.20080714081843.32">we will implement some forms methods.</t>
<t tx="sa.20080714081843.33">GoFlow Advanced
============================</t>
<t tx="sa.20080714081843.34">    * use goflow svn version as version 0.5 will not work with these tutorials. You can also 
      download the [http://goflow.googlecode.com/files/goflow-0.51.zip v 0.51].
  
    * It is helpful to have a "played" with the demo goflow leave (available online). 
      [http://goflow.alwaysdata.net/leave/]

(tutorial draft; screenshots will be added later)</t>
<t tx="sa.20080714081843.35">We will simulate here coding an existing application of the demo ``Leave``: ``hrform``.

    * Launch the local server of the demo ``leave`` in the ``leavedemo`` folder (cf. INSTALL.TXT 
      file)
  
    * Go to the admin console: [http://localhost:8000/leave/admin/]
  
    * Create a !LeaveRequest object: [http://localhost:8000/leave/admin/leave/leaverequest/add/]
        * This object will be used as a model when performing unit tests; hence provide the 
          beginning and end dates, type of absence, the requester (admin), and the reason (e.g 
          "test")
          
    * On the applications panel: [http://localhost:8000/leave/admin/workflow/application/]
    
        * Click on the ``create unit test`` link in the ``hrform`` application row: this will 
          create a process with a single activity that will run the application ``hrform``.
          
        * Click on ``return``
        
        * Click  on the ``start test forums`` link in the ``hrform`` application row; then choose 
          the content type ``leave request`` and click ``OK``: this will initiate as many 
          workflow instances as !LeaveRequest instances that we manually manually before (here, 
          only one).
          
    * Go to the task list of the admin user: [http://localhost:8000/leave/mywork/]
    
    * There must be a task for an activity called ``test_activity`` in the workflow process 
      ``test_hrform``
      
    * Clicking on the link ``activate`` should lead you to the panel corresponding to the 
      implementation of the ``hrform`` application.

Here we have simulated/tested an application in a process workflow; it seems very little, but it is important to have in mind that in the development of complex workflows, and in order to efficiently work in teams, each activity should be coded and tested independently of each other. 

That is why GoFlow is equipped with tools, available in the console admin customized for this purpose, to help the developer generate a test environment for each application.
</t>
<t tx="sa.20080714081843.36">We are going to replace an application that currently requires human intervention by an automatic activity. We will work on the previous application ``hrform`` and replace it with the application ``hr_auto`` which will perform the same function but automatically (in fact, this is a simplified version, because calculating the number of days worked between two dates is not trivial).
 
TODO</t>
<t tx="sa.20080714081843.37">The current GoFlow system grew out of the OpenFlow project.
</t>
<t tx="sa.20080714081843.38"></t>
<t tx="sa.20080714081843.39"></t>
<t tx="sa.20080714081843.40"></t>
<t tx="sa.20080714225902.5"></t>
<t tx="sa.20080714225902.6">* new more 'object-oriented' api using model classes and managers

* addition of goflow.utils for custom management commands, decorators, logger, etc...

* better documentation..

</t>
<t tx="sa.20080714225902.7">* fixes here...</t>
<t tx="sa.20080714225902.8">* new api...


</t>
<t tx="sa.20080714235246.1"></t>
<t tx="sa.20080715012904.1">.. _credits:

==============================
Credits and Acknowledgements
==============================




We are grateful to x, y and z for support of this project.

    * GoFlow is based on OpenFlow
    
    * etc..
</t>
<t tx="sa.20080715012904.2">.. _license:

==========================
License
==========================


insert license here.</t>
<t tx="sa.20080715111354.1">GoFlow is an "activity based" workflow. Workflow processes are implemented as a set of activities that must be completed to achieve some result. In GoFlow, the logic of activities lies in python view scripts. The presentation consists of a django (or any other kind of) template. GoFlow provides three main modules: 

    * Workflow API, 
    * Workflow Runtime
    * Workflow Admin.

</t>
<t tx="sa.20080715111354.2"></t>
<t tx="sa.20080715111354.3">A process is defined as a set of activities that must be done to achieve some goal. Business interactions are mapped to GoFlow processes to automate them. Process activities are connected using transitions defining what has to be done after each activity is completed.

</t>
<t tx="sa.20080715111354.4">An activity is a task that must be completed as a part of a process. In GoFlow activities are mapped to python scripts. This way an activity can do anything that can be done from a python script.</t>
<t tx="sa.20080715111354.5">Transitions defines which activity or activities come before an activity is executed and after it is completed.
</t>
<t tx="sa.20080715111354.6">Roles define who can perform an associated activity. Roles are defined at a per-process level.

</t>
<t tx="sa.20080715111354.7">An instance is an occurrence of a process being executed. An instance is created when a process is started. The instance passes through the process activities until the process is terminated.

</t>
<t tx="sa.20080715111354.8">A workitem is added to the instance when an activity is completed. Workitems thus represent completed activities.

</t>
<t tx="sa.20080715111354.9">GoFlow defines seven basic activity types that can be used to design a process. They are:

    * Start
    * End
    * Activity
    * Switch
    * Split
    * Join
    * Standalone 
</t>
<t tx="sa.20080715111354.10">Start activities
--------------------
	Start activities are represented using a circle. Every process must have at least one start activity. Start is the only activity type that can be executed without the presence of an instance in the activity because instances are created when a start activity is executed. Processes with many start activities are awkward but possible in GoFlow. No transitions can lead to a start activity and only one outgoing transition is allowed per start activity.
    </t>
<t tx="sa.20080715111354.11">The end activity represents the end of a process. When an instance reaches the end activity the process is considered completed. Process must have exactly one end activity. This doesnt mean that processes cant end in different ways, since the end activity represents only that the process ends. How the process ends depends on the activities visited before the end activity. The end activity is represented in GoFlow using a double circle. The end activity can have many inbound transitions. Outbound transitions are not allowed.


Rules: Valid processes must have at least one begin activity and exactly one end activity. There must be at least one path leading from a start activity to the end activity.
</t>
<t tx="sa.20080715111354.12">Normal activities dont have a special meaning so they are used to represent tasks that should be done as a part of a process. A rectangle is used to represent these activities. Normal activities can receive many inbound transitions but can only have one outbound transition.</t>
<t tx="sa.20080715111354.13">A switch activity represents a point of decision in a process. Instances reaching a switch activity are evaluated and depending on some conditions the instance can be routed to different activities. Switch activities can have many inbound transitions and many outbound transitions. Switch activities are represented using a diamond.
</t>
<t tx="sa.20080715111354.14">Sometimes two or more activities in a process can be done independently in parallel. A split activity is used to split an instance and route it to many activities. This way an instance can be in many activities at the same time. Split activities represent subflows in a workflow. A split activity can receive many inbound transitions and can have many outbound transitions. Split activities are represented by a triangle.</t>
<t tx="sa.20080715111354.15">A join activity is used to regroup instances splitted from a split activity. When an instance reaches a join activity the engine verifies that the instance is present also in some other activity. If so, the instance must wait in the join activity until all activities leading to the join activity are completed. Once all activities reach the join activity the instance can be directed to the next activity. Join activities can have many inbound transitions (more than one is expected) and can only have one outbound activity. Join activities are represented using an inverted triangle.</t>
<t tx="sa.20080715111354.16">	Standalone activities are represented by hexagons. A standalone activity is not part of the normal flow of the process so they are not related to instances. A standalone activity can be executed any time by an user with the required permissions. These activities are ideal for data management related to the process, listings, adding items, removing items, etc. Many processes can be designed as a set of standalone activities if there's no order relationship between the different activities in the process. Other processes consist of a main process flow and a set of auxiliary standalone activities. Standalone activities cant have inbound nor outbound transitions.</t>
<t tx="sa.20080715111354.17"></t>
<t tx="sa.20080715111354.18">When an activitiy is completed the engine may or may not automatically route the instance to the next activity in the process. Activities with the "AutoRouting" setting activated automatically route the instance to the next process activity when the activity is completed. If the activity is not "AutoRouting" the user must "send" the activity after completion to let the instance continue. This can be used in activities where the user can edit information and review it many times before deciding that the activity is completed.</t>
<t tx="sa.20080715111354.19">In GoFlow activities can be automatic or interactive. Interactive activities are activities that require some kind of interaction from the user. These activities usually present a form asking the user to fill some data. After the information is submitted the activity is completed. Automatic activities in contrast are executed automatically by the GoFlow engine without any user interaction. Frequently automatic activities are hidden from the user view of a process.

    * Auto-routed activities have red arrows going out of them.
    * Non-auto-routed activities have black arrows going out of them.
    * Interactive activities have blue borders.
    * Automatic activities have black borders. </t>
<t tx="sa.20080715111354.20">	The picture on the left shows the graph of a process. This process defines requests to a shared CD collection. The start activity (interactive) is where the user picks a CD. Then the manager must verify that the CD is available in the "Approve loan" activity. If the CD is available, the manager sends the CD to the user, and the request is accepted. If not, the request is rejected. The standalone activity "Browse CDs" can be used by the user or the manager to browse the CD collection.</t>
<t tx="sa.20080715111354.21">GoFlow defines three modules:

    * The Process Manager
    * The User Interafce
    * The Process Monitor 
</t>
<t tx="sa.20080715111354.22">The process manager is the module used to create and modify processes. This module is normally used by an administrator and process designers to create processes. The process manager covers the following functionality:

    * Create process and process versions
    * Create, rename, edit and delete activities
    * View a graph of the process activities
    * Check if a process is valid
    * Activate/de-activate a process
    * Edit the source code of activities (python scripts) and templates (Smarty templates)
    * Define roles and define what roles are allowed to execute what activities
    * Map users to roles
    * Export processes to XML files (backup)
    * Load processes from XML files (restore) 

</t>
<t tx="sa.20080715111354.23">The user interface is used by the users to browse processes where they can start new instances, or run activities to which their role has permissions and belong to a particular instance. Users can execute activities, and see the results and some statistics about work asssigned to them.

</t>
<t tx="sa.20080715111354.24">The process monitor is used to monitor and control the execution of processes. The following list shows some features of the process monitor API.

    * List processes, process activities and number of instances per activity
    * List active instances and exceptions
    * Browse instances and modify instance properties
    * Send instances to some activity
    * Assign or reassign an instance to some user
    * Abort instances
    * View statistics about completed processes, execution time, and time spent per activity 

</t>
<t tx="sa.20080715111354.25">
A workflow is a model to represent real work for further assessment, e.g., for describing a reliably repeatable sequence of operations. More abstractly, a workflow is a pattern of activity enabled by a systematic organization of resources, defined roles and mass, energy and information flows, into a work process that can be documented and learned.

The term workflow is used in computer programming to capture and develop human to machine interaction. Workflow software aims to provide end users with an easier way to orchestrate or describe complex processing of data in a visual form, much like flow charts but without the need to understand computers or programming.

Workflow is a term used to describe the tasks, procedural steps, organizations or people involved, required input and output information, and tools needed for each step in a business process. 

A workflow approach to analyzing and managing a business process can be combined with an object-oriented programming approach, which tends to focus on documents and data. In general, workflow management focuses on processes rather than documents. 

A number of companies make workflow automation products that allow a company to create a workflow model and components such as online forms and then to use this product as a way to manage and enforce the consistent handling of work. For example, an insurance company could use a workflow automation application to ensure that a claim was handled consistently from initial call to final settlement. The workflow application would ensure that each person handling the claim used the correct online form and successfully completed their step before allowing the process to proceed to the next person and procedural step.

A workflow engine is the component in a workflow automation program that knows all the procedures, steps in a procedure, and rules for each step. The workflow engine determines whether the process is ready to move to the next step. 

Proponents of the workflow approach believe that task analysis and workflow modeling in themselves are likely to improve business operations.



related concepts: 

    * Petri-Nets: http://en.wikipedia.org/wiki/Petri_net
    </t>
<t tx="sa.20080715122316.2"></t>
<t tx="sa.20080715122316.3"></t>
<t tx="sa.20080715122316.4"></t>
<t tx="sa.20080715122316.5"></t>
<t tx="sa.20080715122316.6"></t>
<t tx="sa.20080715122316.7"></t>
<t tx="sa.20080715122316.8"></t>
<t tx="sa.20080715122316.9"></t>
<t tx="sa.20080715122316.10"></t>
<t tx="sa.20080715122316.11"></t>
<t tx="sa.20080715122316.12"></t>
<t tx="sa.20080716081317.2"></t>
<t tx="sa.20080716081317.3"></t>
<t tx="sa.20080716081317.4">import os
os.system('./scripts/build_docs')
</t>
<t tx="sa.20080716081317.5"></t>
<t tx="sa.20080717192016.4"></t>
<t tx="sa.20080717192016.5">The convergence of two or more branches into a single subsequent branch such that the thread of control is passed to the subsequent branch when all input branches have been enabled.</t>
<t tx="sa.20080717192016.6">synchronization, rendezvous, synchronizer.</t>
<t tx="sa.20080717192016.7">The dispatch-goods task runs immediately after both the check-invoice and produce-invoice tasks are completed.

Cash-drawer reconciliation can only occur when the store has been closed and the credit card summary has been printed.
</t>
<t tx="sa.20080717192016.8">The AND-join patterns provides a means of reconverging the execution threads of two or more parallel branches. In general, these branches are created using the Parallel Split (AND-split) construct earlier in the process model. The thread of control is passed to the task immediately following the synchronizer once all of the incoming branches have completed.
</t>
<t tx="sa.20080717192016.9">The divergence of a branch into two or more parallel branches each of which execute concurrently.</t>
<t tx="sa.20080717192016.10">AND-split, parallel routing, parallel split, fork.</t>
<t tx="sa.20080717192016.11">After completion of the capture enrolment task, run the create student profile and issue enrolment confirmation tasks simultaneously.

When an intrusion alarm is received, trigger the despatch patrol task and the inform police task immediately.

Once the customer has paid for the goods, pack them and issue a receipt.

</t>
<t tx="sa.20080717192016.12">The AND-Split pattern allows a single thread of execution to be split into two or more branches which can execute tasks concurrently. These branches may or may not be re-synchronized at some future time.
</t>
<t tx="sa.20080717192016.13"></t>
<t tx="sa.20080717192016.14">A task in a process in enabled after the completion of a preceding task in the same process.</t>
<t tx="sa.20080717192016.15">Sequential routing, serial routing.</t>
<t tx="sa.20080717192016.16">The verify-account task executes after the credit card details have been captured.

The codacil-signature task follows the contract-signature task.

A receipt is printed after the train ticket is issued.</t>
<t tx="sa.20080717192016.17">The Sequence pattern serves as the fundamental building block for processes. It is used to construct a series of consecutive tasks which execute in turn one after the other. Two tasks form part of a Sequence if there is a control-flow edge from one of them to the next which has no guards or conditions associated with it.</t>
<t tx="sa.20080717192016.18">

..  image:: images/xor-join.png
    :align: center

</t>
<t tx="sa.20080717192016.19">The convergence of two or more branches into a single subsequent branch such that each enablement of an incoming branch results in the thread of control being passed to the subsequent branch.</t>
<t tx="sa.20080717192016.20">Simple Merge, XOR-join, exclusive OR-join, asynchronous join, merge.</t>
<t tx="sa.20080717192016.21">At the conclusion of either the bobcat-excavation or the D9-excavation tasks, an estimate of the amount of earth moved is made for billing purposes.

After the case-payment or provide-credit tasks, initiate the product-receipt task.
</t>
<t tx="sa.20080717192016.22">The Simple Merge pattern provides a means of merging two or more distinct branches without synchronizing them. As such, this presents the opportunity to simplify a process model by removing the need to explicitly replicate a sequence of tasks that is common to two or more branches. Instead, these branches can be joined with a simple merge construct and the common set of tasks need only to be depicted once in the process model.</t>
<t tx="sa.20080717192016.23">

..  image:: images/xor-split.png
    :align: center

</t>
<t tx="sa.20080717192016.24">The divergence of a branch into two or more branches such that when the incoming branch is enabled, the thread of control is immediately passed to precisely one of the outgoing branches based on a mechanism that can select one of the outgoing branches.</t>
<t tx="sa.20080717192016.25">Exclusive choice, XOR-split, exclusive OR-split, conditional routing, switch, decision, case statement.</t>
<t tx="sa.20080717192016.26">Depending on the volume of earth to be moved, either the dispatch-backhoe, dispatch-bobcat or dispatch-D9-excavator task is initiated to complete the job.

After the review election task is completed, either the declare results or the recount votes task is undertaken.</t>
<t tx="sa.20080717192016.27">The Exclusive Choice pattern allows the thread of control to be directed to a specific (subsequent) task depending on the outcome of a preceding task, the values of elements of specific data elements in the process, the results of an expression evaluation or some other form of programmatic selection mechanism. The routing decision is made dynamically allowing it to be deferred to the latest possible moment at runtime.


</t>
<t tx="sa.20080720191846.1"></t>
<t tx="sa.20080720192331.1"></t>
<t tx="sa.20080720192331.2">
	* Improved documentation based on leo-editor, Sphinx and epydoc. 
</t>
<t tx="sa.20080720192331.3">	* a bug was found here.

</t>
<t tx="sa.20080720192331.4">	* api was cleaned up to make it more consistent.

</t>
<t tx="sa.20080720195210.1">import os
join = os.path.join

def cmd(command):
    print '--&gt;', command
    os.system(command)

print "CLEANING Goflow environment..."

# clean generated docs
root = 'docs/build'
for entry in ['html', 'doctrees']:
    cmd('rm -rf %s' % join(root, entry))

# clean *.pycs and .log files
cmd('scripts/clean')
</t>
<t tx="sa.20080724074952.1">.. _todo:

==========================
TODOs
==========================

.. contents::




</t>
<t tx="sa.20080724074952.2"></t>
<t tx="sa.20080724074952.3">* moved api into models and managers to make it more object oriented, still some way to go...

</t>
<t tx="sa.20080724074952.10"></t>
<t tx="sa.20080724074952.11">* sphinx autodoc now working 
* add uml diagram of model (80%)</t>
<t tx="sa.20080724074952.12">- use custom log class for all logging (including event logging)
</t>
<t tx="sa.20080724074952.13">@ignore</t>
<t tx="sa.20080724074952.15">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="sa.20080724074952.16">##############################################################################
#
# Copyright (c) 2004 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Attribute-based integration components


$Id: attributeintegration.py 30314 2005-05-09 17:07:09Z jim $
"""

from zope.wfmc import interfaces
from zope import interface

</t>
<t tx="sa.20080724074952.17">class AttributeIntegration:
    """Integration component that uses simple attributes

    Subclasses provide attributes with suffices Participant or Application to
    provide participant and application factories of a given name.
    """

    interface.implements(interfaces.IIntegration)

    @others
</t>
<t tx="sa.20080724074952.18">def createParticipant(self, activity,
                      process_definition_identifier, performer):
    return getattr(self, performer+'Participant')(activity)


</t>
<t tx="sa.20080724074952.19">def createWorkItem(self, participant,
                   process_definition_identifier, application):
    return getattr(self, application+'WorkItem')(participant)
</t>
<t tx="sa.20080724074952.20">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="sa.20080724074952.21">##############################################################################
#
# Copyright (c) 2004 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Workflow-integration interfaces

$Id: interfaces.py 70052 2006-09-08 12:27:59Z adamg $
"""
__docformat__ = "reStructuredText"

from zope import interface

</t>
<t tx="sa.20080724074952.22">class IIntegration(interface.Interface):
    """Integration of a workflow definition with an application environment

    ``IIntegration`` objects provide methods for integrating workflow
    process definition with an application environment.
    """
    @others
</t>
<t tx="sa.20080724074952.23">

def createParticipant(activity, process_definition_identifier, performer):
    """Create a participant for an activity

    The process id and especially the performer (id) are used to
    select an appropriate participant type.
    """

</t>
<t tx="sa.20080724074952.24">def createWorkItem(participant,
                   process_definition_identifier, application):
    """Create a work item for the given participant

    The process id and especially the application (id) are used to
    select an appropriate work-item type.
    """

</t>
<t tx="sa.20080724074952.25">class IProcessDefinition(interface.Interface):
    """Process definition

    A process definition defines a particular workflow and define the control
    and flow of the work. You can think of them as the workflow blueprint.
    """

    id = interface.Attribute("Process-definition identifier")

    __name__ = interface.Attribute("Name")

    description = interface.Attribute("Description")

    integration = interface.Attribute(
        """Environment-integration component

        The integration component is used to hook up a process
        definition with an application environment.

        This is an ``IIntegration``.
        """
        )

    participants = interface.Attribute(
        """Process participants

        This is a mapping from participant id to participant definition
        """
        )

    activities = interface.Attribute(
        """Process activities

        This is a mapping from activity id to activity definition
        """
        )

    applications = interface.Attribute(
        """Process applications

        This is a mapping from application id to participant definitions
        """
        )

    @others
</t>
<t tx="sa.20080724074952.26">def defineActivities(**activities):
    """Add activity definitions to the collection of defined activities

    Activity definitions are supplied as keyword arguments.  The
    keywords provide activity identifiers.  The values are
    IActivityDefinition objects.

    """

</t>
<t tx="sa.20080724074952.27">def defineTransitions(*transitions):
    """Add transition definitions

    The transitions are ITransition objects.
    """

</t>
<t tx="sa.20080724074952.28">def defineParticipants(**participants):
    """Declare participants

    The participants are provided as keyword arguments.
    Participant identifiers are supplied as the keywords and the
    definitions are supplied as values.  The definitions are
    IParticipantDefinition objects.
    """

</t>
<t tx="sa.20080724074952.29">def defineApplications(**applications):
    """Declare applications

    The applications are provided as keyword arguments.
    Application identifiers are supplied as the keywords and the
    definitions are supplied as values.  The definitions are
    IApplicationDefinition objects.
    """

</t>
<t tx="sa.20080724074952.30">def defineParameters(*parameters):
    """Declate process parameters

    Input parameters are set as workflow-relevant data.  Output
    parameters are passed from workflow-relevant data to the
    processFinished method of process-instances process contexts.

    """

</t>
<t tx="sa.20080724074952.31">class IActivityDefinition(interface.Interface):
    """Activity definition
    """

    id = interface.Attribute("Activity identifier")

    __name__ = interface.Attribute("Activity Name")

    description = interface.Attribute("Description")

    @others
</t>
<t tx="sa.20080724074952.32">def addApplication(id, *parameters):
    """Declare that the activity uses the identified activity

    The application identifier must match an application declared
    for the process.

    Parameter definitions can be given as positional arguments.
    The parameter definition directions must match those given in
    the application definition.
    """

</t>
<t tx="sa.20080724074952.33">def definePerformer(performer):
    """Set the activity performer

    The argument must be the identifier of a participant defined
    for the enclosing process.
    """

</t>
<t tx="sa.20080724074952.34">def setAndSplit(setting):
    """Provide an and-split setting

    If the setting is true, then the activity will use an "and" split.
    """

</t>
<t tx="sa.20080724074952.35">def setAndJoin(setting):
    """Provide an and-join setting

    If the setting is true, then the activity will use an "and" join.
    """

</t>
<t tx="sa.20080724074952.36">class ITransitionDefinition(interface.Interface):
    """Transition definition
    """
    id = interface.Attribute("Transition identifier")

    __name__ = interface.Attribute(
        "Transition name, Text used to identify the Transition.")

    description = interface.Attribute("Description")

    from_ = interface.Attribute(
        "Determines the FROM source of a Transition. (Activity Identifier)")

    to = interface.Attribute(
        "Determines the TO target of a Transition (Activity Identifier)")

    condition = interface.Attribute(
        "A Transition condition expression based on relevant data field.")

</t>
<t tx="sa.20080724074952.37">class IProcess(interface.Interface):
    """Process instance
    """

    definition = interface.Attribute("Process definition")

    workflowRelevantData = interface.Attribute(
        """Workflow-relevant data

        Object with attributes containing data used in conditions and
        to pass data as parameters between applications
        """
        )

    applicationRelevantData = interface.Attribute(
        """Application-relevant data

        Object with attributes containing data used to pass data as
        shared data for applications

        """
        )

</t>
<t tx="sa.20080724074952.38">class IProcessContext(interface.Interface):
    """Object that can receive process results.
    """
    @others
</t>
<t tx="sa.20080724074952.39">
def processFinished(process, *results):
    """Receive notification of process completion, with results
    """

</t>
<t tx="sa.20080724074952.40">class IActivity(interface.Interface):
    """Activity instance
    """

    id = interface.Attribute(
        """Activity identifier

        This identifier is set by the process instance

        """)

    definition = interface.Attribute("Activity definition")

    @others
</t>
<t tx="sa.20080724074952.41">def workItemFinished(work_item, *results):
    """Notify the activity that the work item has been completed.
    """

</t>
<t tx="sa.20080724074952.42">class IApplicationDefinition(interface.Interface):
    """Application definition
    """

    __name__ = interface.Attribute("Name")

    description = interface.Attribute("Description")

    parameters = interface.Attribute(
        "A sequence of parameter definitions")

</t>
<t tx="sa.20080724074952.43">class IParameterDefinition(interface.Interface):
    """Parameter definition
    """

    name = interface.Attribute("Parameter name")

    input = interface.Attribute("Is this an input parameter?")

    output = interface.Attribute("Is this an output parameter?")

</t>
<t tx="sa.20080724074952.44">class IParticipantDefinition(interface.Interface):
    """Participant definition
    """

</t>
<t tx="sa.20080724074952.45">class IParticipant(interface.Interface):
    """Workflow participant
    """

    __name__ = interface.Attribute("Name")

    description = interface.Attribute("Description")

</t>
<t tx="sa.20080724074952.46">class IWorkItem(interface.Interface):
    """Work items
    """

    id = interface.Attribute(
        """Item identifier

        This identifier is set by the activity instance

        """)

    @others
</t>
<t tx="sa.20080724074952.47">def start(*arguments):
    """Start the work
    """


</t>
<t tx="sa.20080724074952.48">class InvalidProcessDefinition(Exception):
    """A process definition isn't valid in some way.
    """

</t>
<t tx="sa.20080724074952.49">class ProcessError(Exception):
    """An error occurred in execution of a process.
    """

</t>
<t tx="sa.20080724074952.50">class IProcessStarted(interface.Interface):
    """A process has begun executing
    """

    process = interface.Attribute("The process")

</t>
<t tx="sa.20080724074952.51">class IProcessFinished(interface.Interface):
    """A process has finished executing
    """

    process = interface.Attribute("The process")
</t>
<t tx="sa.20080724074952.52">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="sa.20080724074952.53">##############################################################################
#
# Copyright (c) 2004 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Processes

$Id: process.py 70052 2006-09-08 12:27:59Z adamg $
"""

import persistent

import zope.cachedescriptors.property

from zope import component, interface

import zope.event

from zope.wfmc import interfaces

</t>
<t tx="sa.20080724074952.54">def always_true(data):
    return True

</t>
<t tx="sa.20080724074952.55">class TransitionDefinition(object):

    interface.implements(interfaces.ITransitionDefinition)

    @others
</t>
<t tx="sa.20080724074952.56">def __init__(self, from_, to, condition=always_true, id=None, __name__=None):
    self.id = id
    self.from_ = from_
    self.to = to
    self.condition = condition
    self.__name__ = __name__
    self.description = None

</t>
<t tx="sa.20080724074952.57">def __repr__(self):
    return "TransitionDefinition(from=%r, to=%r)" %(self.from_, self.to)


</t>
<t tx="sa.20080724074952.58">class ProcessDefinition(object):

    interface.implements(interfaces.IProcessDefinition)

    TransitionDefinitionFactory = TransitionDefinition

    @others
</t>
<t tx="sa.20080724074952.59">def __init__(self, id, integration=None):
    self.id = id
    self.integration = integration
    self.activities = {}
    self.transitions = []
    self.applications = {}
    self.participants = {}
    self.parameters = ()
    self.description = None

</t>
<t tx="sa.20080724074952.60">def __repr__(self):
    return "ProcessDefinition(%r)" % self.id

</t>
<t tx="sa.20080724074952.61">def defineActivities(self, **activities):
    self._dirty()
    for id, activity in activities.items():
        activity.id = id
        if activity.__name__ is None:
            activity.__name__ = self.id + '.' + id
        activity.process = self
        self.activities[id] = activity

</t>
<t tx="sa.20080724074952.62">def defineTransitions(self, *transitions):
    self._dirty()
    self.transitions.extend(transitions)

    # Compute activity transitions based on transition data:
    activities = self.activities
    for transition in transitions:
        activities[transition.from_].transitionOutgoing(transition)
        activities[transition.to].incoming += (transition, )

</t>
<t tx="sa.20080724074952.63">def defineApplications(self, **applications):
    for id, application in applications.items():
        application.id = id
        self.applications[id] = application

</t>
<t tx="sa.20080724074952.64">def defineParticipants(self, **participants):
    for id, participant in participants.items():
        participant.id = id
        self.participants[id] = participant

</t>
<t tx="sa.20080724074952.65">def defineParameters(self, *parameters):
    self.parameters += parameters

</t>
<t tx="sa.20080724074952.66">def _start(self):
    # Return an initial transition

    activities = self.activities

    # Find the start, making sure that there is one and that there
    # aren't any activities with no transitions:
    start = ()
    for aid, activity in activities.items():
        if not activity.incoming:
            start += ((aid, activity), )
            if not activity.outgoing:
                raise interfaces.InvalidProcessDefinition(
                    "Activity %s has no transitions" %aid)

    if len(start) != 1:
        if start:
            raise interfaces.InvalidProcessDefinition(
                "Multiple start activities",
                [id for (id, a) in start]
                )
        else:
            raise interfaces.InvalidProcessDefinition(
                "No start activities")

    return self.TransitionDefinitionFactory(None, start[0][0])

</t>
<t tx="sa.20080724074952.67">_start = zope.cachedescriptors.property.Lazy(_start)

def __call__(self, context=None):
    return Process(self, self._start, context)

</t>
<t tx="sa.20080724074952.68">def _dirty(self):
    try:
        del self._start
    except AttributeError:
        pass

</t>
<t tx="sa.20080724074952.69">class ActivityDefinition(object):

    interface.implements(interfaces.IActivityDefinition)

    performer = ''
    process = None

    @others
</t>
<t tx="sa.20080724074952.70">def __init__(self, __name__=None):
    self.__name__ = __name__
    self.incoming = self.outgoing = ()
    self.transition_outgoing = self.explicit_outgoing = ()
    self.applications = ()
    self.andJoinSetting = self.andSplitSetting = False
    self.description = None

</t>
<t tx="sa.20080724074952.71">def andSplit(self, setting):
    self.andSplitSetting = setting

</t>
<t tx="sa.20080724074952.72">def andJoin(self, setting):
    self.andJoinSetting = setting

</t>
<t tx="sa.20080724074952.73">def addApplication(self, application, actual=()):
    app = self.process.applications[application]
    formal = app.parameters
    if len(formal) != len(actual):
        raise TypeError("Wrong number of parameters =&gt; "
                        "Actual=%s, Formal=%s for Application %s with id=%s"
                        %(actual, formal, app, app.id))
    self.applications += ((application, formal, tuple(actual)), )

</t>
<t tx="sa.20080724074952.74">def definePerformer(self, performer):
    self.performer = performer

</t>
<t tx="sa.20080724074952.75">def addOutgoing(self, transition_id):
    self.explicit_outgoing += (transition_id,)
    self.computeOutgoing()

</t>
<t tx="sa.20080724074952.76">def transitionOutgoing(self, transition):
    self.transition_outgoing += (transition,)
    self.computeOutgoing()

</t>
<t tx="sa.20080724074952.77">def computeOutgoing(self):
    if self.explicit_outgoing:
        transitions = dict([(t.id, t) for t in self.transition_outgoing])
        self.outgoing = ()
        for tid in self.explicit_outgoing:
            transition = transitions.get(tid)
            if transition is not None:
                self.outgoing += (transition,)
    else:
        self.outgoing = self.transition_outgoing

</t>
<t tx="sa.20080724074952.78">def __repr__(self):
    return "&lt;ActivityDefinition %r&gt;" %self.__name__


</t>
<t tx="sa.20080724074952.79">class Process(persistent.Persistent):

    interface.implements(interfaces.IProcess)

    @others
</t>
<t tx="sa.20080724074952.80">def __init__(self, definition, start, context=None):
    self.process_definition_identifier = definition.id
    self.startTransition = start
    self.context = context
    self.activities = {}
    self.nextActivityId = 0
    self.workflowRelevantData = WorkflowData()
    self.applicationRelevantData = WorkflowData()

</t>
<t tx="sa.20080724074952.81">def definition(self):
    return component.getUtility(
        interfaces.IProcessDefinition,
        self.process_definition_identifier,
        )
</t>
<t tx="sa.20080724074952.82">definition = property(definition)

def start(self, *arguments):
    if self.activities:
        raise TypeError("Already started")

    definition = self.definition
    data = self.workflowRelevantData
    args = arguments
    for parameter in definition.parameters:
        if parameter.input:
            arg, args = args[0], args[1:]
            setattr(data, parameter.__name__, arg)
    if args:
        raise TypeError("Too many arguments. Expected %s. got %s" %
                        (len(definition.parameters), len(arguments)))

    zope.event.notify(ProcessStarted(self))
    self.transition(None, (self.startTransition, ))

</t>
<t tx="sa.20080724074952.83">def outputs(self):
    outputs = []
    for parameter in self.definition.parameters:
        if parameter.output:
            outputs.append(
                getattr(self.workflowRelevantData,
                        parameter.__name__))

    return outputs

</t>
<t tx="sa.20080724074952.84">def _finish(self):
    if self.context is not None:
        self.context.processFinished(self, *self.outputs())

    zope.event.notify(ProcessFinished(self))


</t>
<t tx="sa.20080724074952.85">def transition(self, activity, transitions):
    if transitions:
        definition = self.definition

        for transition in transitions:
            activity_definition = definition.activities[transition.to]
            next = None
            if activity_definition.andJoinSetting:
                # If it's an and-join, we want only one.
                for i, a in self.activities.items():
                    if a.activity_definition_identifier == transition.to:
                        # we already have the activity -- use it
                        next = a
                        break

            if next is None:
                next = Activity(self, activity_definition)
                self.nextActivityId += 1
                next.id = self.nextActivityId

            zope.event.notify(Transition(activity, next))
            self.activities[next.id] = next
            next.start(transition)

    if activity is not None:
        del self.activities[activity.id]
        if not self.activities:
            self._finish()

    self._p_changed = True

</t>
<t tx="sa.20080724074952.86">def __repr__(self):
    return "Process(%r)" % self.process_definition_identifier

</t>
<t tx="sa.20080724074952.87">class WorkflowData(persistent.Persistent):
    """Container for workflow-relevant and application-relevant data
    """

</t>
<t tx="sa.20080724074952.88">class ProcessStarted:
    interface.implements(interfaces.IProcessStarted)

    @others
</t>
<t tx="sa.20080724074952.89">def __init__(self, process):
    self.process = process

</t>
<t tx="sa.20080724074952.90">def __repr__(self):
    return "ProcessStarted(%r)" % self.process

</t>
<t tx="sa.20080724074952.91">class ProcessFinished:
    interface.implements(interfaces.IProcessFinished)

    @others
</t>
<t tx="sa.20080724074952.92">def __init__(self, process):
    self.process = process

</t>
<t tx="sa.20080724074952.93">def __repr__(self):
    return "ProcessFinished(%r)" % self.process


</t>
<t tx="sa.20080724074952.94">class Activity(persistent.Persistent):

    interface.implements(interfaces.IActivity)

    @others
</t>
<t tx="sa.20080724074952.95">def __init__(self, process, definition):
    self.process = process
    self.activity_definition_identifier = definition.id

    integration = process.definition.integration

    workitems = {}
    if definition.applications:

        participant = integration.createParticipant(
            self,
            process.process_definition_identifier,
            definition.performer,
            )

        i = 0
        for application, formal, actual in definition.applications:
            workitem = integration.createWorkItem(
                participant,
                process.process_definition_identifier,
                application,
                )
            i += 1
            workitem.id = i
            workitems[i] = workitem, application, formal, actual

    self.workitems = workitems

</t>
<t tx="sa.20080724074952.96">def definition(self):
    return self.process.definition.activities[
        self.activity_definition_identifier]
</t>
<t tx="sa.20080724074952.97">definition = property(definition)

incoming = ()
def start(self, transition):
    # Start the activity, if we've had enough incoming transitions

    definition = self.definition

    if definition.andJoinSetting:
        if transition in self.incoming:
            raise interfaces.ProcessError(
                "Repeated incoming %s with id='%s' "
                "while waiting for and completion"
                %(transition, transition.id))
        self.incoming += (transition, )

        if len(self.incoming) &lt; len(definition.incoming):
            return # not enough incoming yet

    zope.event.notify(ActivityStarted(self))

    if self.workitems:
        for workitem, app, formal, actual in self.workitems.values():
            args = []
            for parameter, name in zip(formal, actual):
                if parameter.input:
                    args.append(
                        getattr(self.process.workflowRelevantData, name))
            workitem.start(*args)
    else:
        # Since we don't have any work items, we're done
        self.finish()

</t>
<t tx="sa.20080724074952.98">def workItemFinished(self, work_item, *results):
    unused, app, formal, actual = self.workitems.pop(work_item.id)
    self._p_changed = True
    res = results
    for parameter, name in zip(formal, actual):
        if parameter.output:
            v = res[0]
            res = res[1:]
            setattr(self.process.workflowRelevantData, name, v)

    if res:
        raise TypeError("Too many results")

    zope.event.notify(WorkItemFinished(
        work_item, app, actual, results))

    if not self.workitems:
        self.finish()

</t>
<t tx="sa.20080724074952.99">def finish(self):
    zope.event.notify(ActivityFinished(self))

    definition = self.definition

    transitions = []
    for transition in definition.outgoing:
        if transition.condition(self.process.workflowRelevantData):
            transitions.append(transition)
            if not definition.andSplitSetting:
                break # xor split, want first one

    self.process.transition(self, transitions)

</t>
<t tx="sa.20080724074952.100">def __repr__(self):
    return "Activity(%r)" % (
        self.process.process_definition_identifier + '.' +
        self.activity_definition_identifier
        )

</t>
<t tx="sa.20080724074952.101">class WorkItemFinished:
    @others
</t>
<t tx="sa.20080724074952.102">
def __init__(self, workitem, application, parameters, results):
    self.workitem =  workitem
    self.application = application
    self.parameters = parameters
    self.results = results

</t>
<t tx="sa.20080724074952.103">def __repr__(self):
    return "WorkItemFinished(%r)" % self.application

</t>
<t tx="sa.20080724074952.104">class Transition:
    @others
</t>
<t tx="sa.20080724074952.105">
def __init__(self, from_, to):
    self.from_ = from_
    self.to = to

</t>
<t tx="sa.20080724074952.106">def __repr__(self):
    return "Transition(%r, %r)" % (self.from_, self.to)

</t>
<t tx="sa.20080724074952.107">class ActivityFinished:
    @others
</t>
<t tx="sa.20080724074952.108">
def __init__(self, activity):
    self.activity = activity

</t>
<t tx="sa.20080724074952.109">def __repr__(self):
    return "ActivityFinished(%r)" % self.activity

</t>
<t tx="sa.20080724074952.110">class ActivityStarted:
    @others
</t>
<t tx="sa.20080724074952.111">
def __init__(self, activity):
    self.activity = activity

</t>
<t tx="sa.20080724074952.112">def __repr__(self):
    return "ActivityStarted(%r)" % self.activity

</t>
<t tx="sa.20080724074952.113">class Parameter(object):

    interface.implements(interfaces.IParameterDefinition)

    input = output = False

    @others
</t>
<t tx="sa.20080724074952.114">def __init__(self, name):
    self.__name__ = name

</t>
<t tx="sa.20080724074952.115">class OutputParameter(Parameter):

    output = True

</t>
<t tx="sa.20080724074952.116">class InputParameter(Parameter):

    input = True

</t>
<t tx="sa.20080724074952.117">class InputOutputParameter(InputParameter, OutputParameter):

    pass

</t>
<t tx="sa.20080724074952.118">class Application:

    interface.implements(interfaces.IApplicationDefinition)

    @others
</t>
<t tx="sa.20080724074952.119">def __init__(self, *parameters):
    self.parameters = parameters

</t>
<t tx="sa.20080724074952.120">def defineParameters(self, *parameters):
    self.parameters += parameters

</t>
<t tx="sa.20080724074952.121">def __repr__(self):
    input = u', '.join([param.__name__ for param in self.parameters
                       if param.input == True])
    output = u', '.join([param.__name__ for param in self.parameters
                       if param.output == True])
    return "&lt;Application %r: (%s) --&gt; (%s)&gt;" %(self.__name__, input, output)


</t>
<t tx="sa.20080724074952.122">class Participant:

    interface.implements(interfaces.IParticipantDefinition)

    @others
</t>
<t tx="sa.20080724074952.123">def __init__(self, name=None):
    self.__name__ = name
    self.description = None

</t>
<t tx="sa.20080724074952.124">def __repr__(self):
    return "Participant(%r)" %self.__name__
</t>
<t tx="sa.20080724074952.125">@ignore
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Package Id="Publication" xmlns="http://www.wfmc.org/2002/XPDL1.0" xmlns:xpdl="http://www.wfmc.org/2002/XPDL1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.wfmc.org/2002/XPDL1.0 http://wfmc.org/standards/docs/TC-1025_schema_10_xpdl.xsd"&gt;
    &lt;PackageHeader&gt;
        &lt;XPDLVersion&gt;1.0&lt;/XPDLVersion&gt;
        &lt;Vendor&gt;Together&lt;/Vendor&gt;
        &lt;Created&gt;2005-01-06 16:28:27&lt;/Created&gt;
    &lt;/PackageHeader&gt;
    &lt;RedefinableHeader PublicationStatus="UNDER_TEST"/&gt;
    &lt;ConformanceClass GraphConformance="NON_BLOCKED"/&gt;
    &lt;Participants&gt;
        &lt;Participant Id="System"&gt;
            &lt;ParticipantType Type="SYSTEM"/&gt;
        &lt;/Participant&gt;
    &lt;/Participants&gt;
    &lt;Applications&gt;
        &lt;Application Id="prepare"&gt;
            &lt;FormalParameters&gt;
                &lt;FormalParameter Id="publish" Mode="OUT"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/FormalParameter&gt;
            &lt;/FormalParameters&gt;
        &lt;/Application&gt;
        &lt;Application Id="publish"/&gt;
        &lt;Application Id="reject"/&gt;
    &lt;/Applications&gt;
    &lt;WorkflowProcesses&gt;
        &lt;WorkflowProcess AccessLevel="PUBLIC" Id="Publication" Name="Publication"&gt;
            &lt;ProcessHeader DurationUnit="D"&gt;
                &lt;Created&gt;2005-01-06 16:29:02&lt;/Created&gt;
                &lt;Description&gt;This is the sample process&lt;/Description&gt;
            &lt;/ProcessHeader&gt;
            &lt;RedefinableHeader PublicationStatus="UNDER_TEST"/&gt;
            &lt;FormalParameters&gt;
                &lt;FormalParameter Id="author" Mode="IN"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="STRING"/&gt;
                    &lt;/DataType&gt;
                &lt;/FormalParameter&gt;
                &lt;FormalParameter Id="publish" Mode="OUT"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/FormalParameter&gt;
            &lt;/FormalParameters&gt;
            &lt;DataFields&gt;
                &lt;DataField Id="publish" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="tech_changes" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="ed_changes" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="publish1" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="tech_changes1" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="publish2" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
                &lt;DataField Id="tech_changes2" IsArray="FALSE"&gt;
                    &lt;DataType&gt;
                        &lt;BasicType Type="BOOLEAN"/&gt;
                    &lt;/DataType&gt;
                &lt;/DataField&gt;
            &lt;/DataFields&gt;
            &lt;Participants&gt;
                &lt;Participant Id="author" Name="Author"&gt;
                    &lt;ParticipantType Type="ROLE"/&gt;
                &lt;/Participant&gt;
                &lt;Participant Id="tech1" Name="Technical Reviewer 1"&gt;
                    &lt;ParticipantType Type="HUMAN"/&gt;
                    &lt;Description&gt;He is a smart guy.&lt;/Description&gt;
                &lt;/Participant&gt;
                &lt;Participant Id="tech2" Name="Technical Reviewer 2"&gt;
                    &lt;ParticipantType Type="HUMAN"/&gt;
                &lt;/Participant&gt;
                &lt;Participant Id="reviewer" Name="Editorial Reviewer"&gt;
                    &lt;ParticipantType Type="HUMAN"/&gt;
                &lt;/Participant&gt;
            &lt;/Participants&gt;
            &lt;Applications&gt;
                &lt;Application Id="prepare" Name="Prepare"&gt;
                    &lt;Description&gt;Prepare the initial draft&lt;/Description&gt;
                &lt;/Application&gt;
                &lt;Application Id="tech_review"&gt;
                    &lt;FormalParameters&gt;
                        &lt;FormalParameter Id="publish" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="tech_changes" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                    &lt;/FormalParameters&gt;
                &lt;/Application&gt;
                &lt;Application Id="ed_review"&gt;
                    &lt;FormalParameters&gt;
                        &lt;FormalParameter Id="publish1" Mode="IN"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="tech_changes1" Mode="IN"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="publish2" Mode="IN"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="tech_changes2" Mode="IN"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="publish" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="tech_changes" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                        &lt;FormalParameter Id="ed_changes" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                    &lt;/FormalParameters&gt;
                &lt;/Application&gt;
                &lt;Application Id="final"/&gt;
                &lt;Application Id="rfinal"&gt;
                    &lt;FormalParameters&gt;
                        &lt;FormalParameter Id="ed_changes" Mode="OUT"&gt;
                            &lt;DataType&gt;
                                &lt;BasicType Type="BOOLEAN"/&gt;
                            &lt;/DataType&gt;
                        &lt;/FormalParameter&gt;
                    &lt;/FormalParameters&gt;
                &lt;/Application&gt;
            &lt;/Applications&gt;
            &lt;Activities&gt;
                &lt;Activity Id="prepare" Name="Prepare"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="prepare" Type="APPLICATION"/&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;author&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;TransitionRestrictions&gt;
                        &lt;TransitionRestriction&gt;
                            &lt;Join Type="XOR"/&gt;
                            &lt;Split Type="AND"&gt;
                                &lt;TransitionRefs&gt;
                                    &lt;TransitionRef Id="Publication_Tra2"/&gt;
                                    &lt;TransitionRef Id="Publication_Tra3"/&gt;
                                &lt;/TransitionRefs&gt;
                            &lt;/Split&gt;
                        &lt;/TransitionRestriction&gt;
                    &lt;/TransitionRestrictions&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="author"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="110"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="20"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="tech1" Name="Technical Review 1"&gt;
                    &lt;Description&gt;This is the first Technical Review.&lt;/Description&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="tech_review" Type="APPLICATION"&gt;
                            &lt;ActualParameters&gt;
                                &lt;ActualParameter&gt;publish1&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;tech_changes1&lt;/ActualParameter&gt;
                            &lt;/ActualParameters&gt;
                        &lt;/Tool&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;tech1&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="tech1"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="210"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="30"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="tech2" Name="Technical Review 2"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="tech_review" Type="APPLICATION"&gt;
                            &lt;ActualParameters&gt;
                                &lt;ActualParameter&gt;publish2&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;tech_changes2&lt;/ActualParameter&gt;
                            &lt;/ActualParameters&gt;
                        &lt;/Tool&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;tech2&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="tech2"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="190"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="20"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="review" Name="Editorial Review"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="ed_review" Type="APPLICATION"&gt;
                            &lt;ActualParameters&gt;
                                &lt;ActualParameter&gt;publish1&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;tech_changes1&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;publish2&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;tech_changes2&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;publish&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;tech_changes&lt;/ActualParameter&gt;
                                &lt;ActualParameter&gt;ed_changes&lt;/ActualParameter&gt;
                            &lt;/ActualParameters&gt;
                        &lt;/Tool&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;reviewer&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;TransitionRestrictions&gt;
                        &lt;TransitionRestriction&gt;
                            &lt;Join Type="AND"/&gt;
                            &lt;Split Type="XOR"&gt;
                                &lt;TransitionRefs&gt;
                                    &lt;TransitionRef Id="Publication_Tra9"/&gt;
                                    &lt;TransitionRef Id="Publication_Tra8"/&gt;
                                    &lt;TransitionRef Id="Publication_Tra7"/&gt;
                                    &lt;TransitionRef Id="Publication_Tra10"/&gt;
                                &lt;/TransitionRefs&gt;
                            &lt;/Split&gt;
                        &lt;/TransitionRestriction&gt;
                    &lt;/TransitionRestrictions&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="reviewer"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="300"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="20"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="final" Name="Final Preparation"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="final" Type="APPLICATION"/&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;author&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;TransitionRestrictions&gt;
                        &lt;TransitionRestriction&gt;
                            &lt;Join Type="XOR"/&gt;
                        &lt;/TransitionRestriction&gt;
                    &lt;/TransitionRestrictions&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="author"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="370"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="30"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="rfinal" Name="Review Final"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="rfinal" Type="APPLICATION"&gt;
                            &lt;ActualParameters&gt;
                                &lt;ActualParameter&gt;ed_changes&lt;/ActualParameter&gt;
                            &lt;/ActualParameters&gt;
                        &lt;/Tool&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;reviewer&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;TransitionRestrictions&gt;
                        &lt;TransitionRestriction&gt;
                            &lt;Split Type="XOR"&gt;
                                &lt;TransitionRefs&gt;
                                    &lt;TransitionRef Id="Publication_Tra13"/&gt;
                                    &lt;TransitionRef Id="Publication_Tra12"/&gt;
                                &lt;/TransitionRefs&gt;
                            &lt;/Split&gt;
                        &lt;/TransitionRestriction&gt;
                    &lt;/TransitionRestrictions&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="reviewer"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="440"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="20"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="start" Name="Start"&gt;
                    &lt;Implementation&gt;
                        &lt;No/&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;System&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="System"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="60"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="10"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="publish" Name="Publish"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="publish" Type="APPLICATION"/&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;System&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;TransitionRestrictions&gt;
                        &lt;TransitionRestriction&gt;
                            &lt;Join Type="XOR"/&gt;
                        &lt;/TransitionRestriction&gt;
                    &lt;/TransitionRestrictions&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="System"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="540"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="20"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
                &lt;Activity Id="reject" Name="Reject"&gt;
                    &lt;Implementation&gt;
                        &lt;Tool Id="reject" Type="APPLICATION"/&gt;
                    &lt;/Implementation&gt;
                    &lt;Performer&gt;System&lt;/Performer&gt;
                    &lt;StartMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/StartMode&gt;
                    &lt;FinishMode&gt;
                        &lt;Automatic/&gt;
                    &lt;/FinishMode&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="ParticipantID" Value="System"/&gt;
                        &lt;ExtendedAttribute Name="XOffset" Value="540"/&gt;
                        &lt;ExtendedAttribute Name="YOffset" Value="80"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Activity&gt;
            &lt;/Activities&gt;
            &lt;Transitions&gt;
                &lt;Transition From="prepare" Id="Publication_Tra2" Name="Transition to Tech Review 1" To="tech1"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                        &lt;ExtendedAttribute Name="BreakPoint" Value="160;160;1"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="prepare" Id="Publication_Tra3" Name="Transition to Tech Review 2" To="tech2"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                        &lt;ExtendedAttribute Name="BreakPoint" Value="210;290;1"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="tech2" Id="Publication_Tra4" Name="Transition" To="review"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="tech1" Id="Publication_Tra5" Name="Transition" To="review"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="start" Id="Publication_Tra6" Name="Transition" To="prepare"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="review" Id="Publication_Tra7" Name="Transition" To="prepare"&gt;
                    &lt;Condition Type="CONDITION"&gt;tech_changes&lt;/Condition&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="review" Id="Publication_Tra8" Name="Transition" To="final"&gt;
                    &lt;Condition Type="CONDITION"&gt;ed_changes&lt;/Condition&gt;
                    &lt;Description&gt;Use this transition if there are editorial changes required.&lt;/Description&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="review" Id="Publication_Tra9" Name="Transition" To="reject"&gt;
                    &lt;Condition Type="CONDITION"&gt;not publish&lt;/Condition&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="review" Id="Publication_Tra10" Name="Transition" To="publish"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="final" Id="Publication_Tra11" Name="Transition" To="rfinal"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                        &lt;ExtendedAttribute Name="BreakPoint" Value="490;400;1"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="rfinal" Id="Publication_Tra12" Name="Transition" To="final"&gt;
                    &lt;Condition Type="CONDITION"&gt;ed_changes&lt;/Condition&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                        &lt;ExtendedAttribute Name="BreakPoint" Value="440;430;1"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
                &lt;Transition From="rfinal" Id="Publication_Tra13" Name="Transition" To="publish"&gt;
                    &lt;ExtendedAttributes&gt;
                        &lt;ExtendedAttribute Name="RoutingType" Value="NOROUTING"/&gt;
                    &lt;/ExtendedAttributes&gt;
                &lt;/Transition&gt;
            &lt;/Transitions&gt;
            &lt;ExtendedAttributes&gt;
                &lt;ExtendedAttribute Name="ParticipantVisualOrder" Value="tech1;tech2;author;reviewer;System;"/&gt;
            &lt;/ExtendedAttributes&gt;
        &lt;/WorkflowProcess&gt;
    &lt;/WorkflowProcesses&gt;
    &lt;ExtendedAttributes&gt;
        &lt;ExtendedAttribute Name="MadeBy" Value="JaWE"/&gt;
        &lt;ExtendedAttribute Name="Version" Value="1.4.2"/&gt;
    &lt;/ExtendedAttributes&gt;
&lt;/Package&gt;
</t>
<t tx="sa.20080724074952.126">@ignore
@nocolor
Workflow-Management Coalition Workflow Engine
=============================================

This package provides an implementation of a Workflow-Management
Coalition (WFMC) workflow engine.  The engine is provided as a
collection of workflow process components.  Workflow processes can be
defined in Python or via the XML Process-Definition Language, XPDL.

In this document, we'll look at Python-defined process definitions:

    &gt;&gt;&gt; from zope.wfmc import process
    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')

The argument to the process is a process id.

A process has a number of parts.  Let's look at a sample review
process::

                              -----------
                           --&gt;| Publish |
  ----------   ---------- /   -----------
  | Author |--&gt;| Review |-    ----------
  ----------   ---------- \--&gt;| Reject |
                              ----------

Here we have a single start activity and 2 end activities.  We could
have modeled this with a single end activity, but that is not
required.  A single start activity *is* required. A process definition
has a set of activities, with transitions between them.  Let's define
the activities for our process definition:

    &gt;&gt;&gt; pd.defineActivities(
    ...     author  = process.ActivityDefinition(),
    ...     review  = process.ActivityDefinition(),
    ...     publish = process.ActivityDefinition(),
    ...     reject  = process.ActivityDefinition(),
    ...     )

We supply activities as keyword arguments. The argument names provide
activity ids that we'll use when defining transitions:

    &gt;&gt;&gt; pd.defineTransitions(
    ...     process.TransitionDefinition('author', 'review'),
    ...     process.TransitionDefinition('review', 'publish'),
    ...     process.TransitionDefinition('review', 'reject'),
    ...     )

Each transition is constructed with an identifier for a starting
activity, and an identifier for an ending activity.

Before we can use a workflow definition, we have to register it as a
utility. This is necessary so that process instances can find their
definitions.  In addition, the utility name must match the process id:

    &gt;&gt;&gt; import zope.component
    &gt;&gt;&gt; zope.component.provideUtility(pd, name=pd.id)

Now, with this definition, we can execute our workflow.  We haven't
defined any work yet, but we can see the workflow execute.  We'll see
the workflow executing by registering a subscriber that logs workflow
events:

    &gt;&gt;&gt; def log_workflow(event):
    ...     print event

    &gt;&gt;&gt; import zope.event
    &gt;&gt;&gt; zope.event.subscribers.append(log_workflow)

To use the workflow definition, we need to create an instance:

    &gt;&gt;&gt; proc = pd()

Now, if we start the workflow:

    &gt;&gt;&gt; proc.start()
    ProcessStarted(Process('sample'))
    Transition(None, Activity('sample.author'))
    ActivityStarted(Activity('sample.author'))
    ActivityFinished(Activity('sample.author'))
    Transition(Activity('sample.author'), Activity('sample.review'))
    ActivityStarted(Activity('sample.review'))
    ActivityFinished(Activity('sample.review'))
    Transition(Activity('sample.review'), Activity('sample.publish'))
    ActivityStarted(Activity('sample.publish'))
    ActivityFinished(Activity('sample.publish'))
    ProcessFinished(Process('sample'))

we see that we transition immediately into the author activity, then
into review and publish.  Normally, we'd need to do some work in each
activity, and transitions would continue only after work had been
done, however, in this case, we didn't define any work, so each
activity completed immediately.

Note that we didn't transition into the rejected activity.  By
default, when an activity is completed, the first transition for which
its condition evaluates to `True` is used.  By default, transitions
have boolean conditions [1]_ that evaluate to `True`, so the transition
to `publish` is used because it was defined before the transition to
`reject`.  What we want is to transition to `publish` if a reviewer
approves the content for publication, but to `reject` if the reviewer
rejects the content for publication.  We can use a condition for this:

    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')
    &gt;&gt;&gt; zope.component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineActivities(
    ...     author = process.ActivityDefinition(),
    ...     review = process.ActivityDefinition(),
    ...     publish = process.ActivityDefinition(),
    ...     reject = process.ActivityDefinition(),
    ...     )
    &gt;&gt;&gt; pd.defineTransitions(
    ...     process.TransitionDefinition('author', 'review'),
    ...     process.TransitionDefinition(
    ...         'review', 'publish', condition=lambda data: data.publish),
    ...     process.TransitionDefinition('review', 'reject'),
    ...     )

We redefined the workflow process, specifying a condition for the
transition to `publish`.  Boolean conditions are just callable objects that
take a data object and return a boolean value.  The data object is
called "workflow-relevant data".  A process instance has a data object
containing this data.  In the example, above, the condition simply
returned the value of the `publish` attribute. How does this attribute
get set? It needs to be set by the review activity. To do that, we
need to arrange for the activity to set the data.  This brings us to
applications.

Process definitions are meant to be used with different
applications. For this reason, process definitions don't include
application logic.  What they do include is a specifications of the
applications to be invoked and the flow of work-flow-relevant data to
and from the application.  Now, we can define our applications:

    &gt;&gt;&gt; pd.defineApplications(
    ...     author = process.Application(),
    ...     review = process.Application(
    ...         process.OutputParameter('publish')),
    ...     publish = process.Application(),
    ...     reject = process.Application(),
    ...     )

We used the same names for the applications that we used for our
activities. This isn't required, but is a common practice.  Note that
the `review` application includes a specification of an output
parameter.  Now that we've defined our applications, we need to modify
our activities to use them:

    &gt;&gt;&gt; pd.activities['author'].addApplication('author')
    &gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])
    &gt;&gt;&gt; pd.activities['publish'].addApplication('publish')
    &gt;&gt;&gt; pd.activities['reject'].addApplication('reject')

An activity can use many applications, so we call `addApplication`.
In the application definition for the 'review' application, we
provided the name of a workflow-relevent data variable corresponding
to the output parameter defined for the application.  When using an
application in an activity, a workflow-relevent data variable name
must be provided for each of the parameters in the identified
applications's signature.  When an application is used in an activity,
workflow-relevent data are passed for each of the input parameters and
are set by each of the output parameters. In this example, the output
parameter, will be used to add a `publish` attribute to the workflow
relevant data.

Participants
------------

We've declared some applications, and we've wired them up to
activities, but we still haven't specified any application code. Before
we can specify application code, we need to consider who will be
performing the application.  Workflow applications are normally
executed by people, or other external actors.  As with applications,
process definitions allow participants in the workflow to be declared
and identified with activities.  We declare participants much as we
declare applications, except without parameters:

    &gt;&gt;&gt; pd.defineParticipants(
    ...     author   = process.Participant(),
    ...     reviewer = process.Participant(),
    ...     )

In this case, we happened to reuse an activity name for one, but
not both of the participants.  Having defined these participants, we
can associate them with activities:

    &gt;&gt;&gt; pd.activities['author'].definePerformer('author')
    &gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')

Application Integration
-----------------------

To use a process definition to control application logic, we need to
associate it with an "integration" object.

When a process needs to get a participant, it calls createParticipant
on its integration attribute, passing the process id and the
performer id. If an activity doesn't have a
performer, then the procedure above is used with an empty performer id.

Similarly, when a process needs a work item, it calls createWorkItem
on its integration attribute, passing the process id and the
application id.

Work items provide a `start` method, which is used to start the work
and pass input arguments.  It is the responsibility of the work item,
at some later time, to call the `workItemFinished` method on the
activity, to notify the activity that the work item was
completed. Output parameters are passed to the `workItemFinished`
method.

A simple way to create integration objects is with
`zope.wfmc.attributeintegration.AttributeIntegration`.

    &gt;&gt;&gt; from zope.wfmc.attributeintegration import AttributeIntegration
    &gt;&gt;&gt; integration = AttributeIntegration()
    &gt;&gt;&gt; pd.integration = integration

We'll start by defining a simple Participant class:

    &gt;&gt;&gt; import zope.interface
    &gt;&gt;&gt; from zope.wfmc import interfaces

    &gt;&gt;&gt; class Participant(object):
    ...     zope.component.adapts(interfaces.IActivity)
    ...     zope.interface.implements(interfaces.IParticipant)
    ...
    ...     def __init__(self, activity):
    ...         self.activity = activity

We set attributes on the integration for each participant:

    &gt;&gt;&gt; integration.authorParticipant   = Participant
    &gt;&gt;&gt; integration.reviewerParticipant = Participant

We also define an attribute for participants for activities that don't
have performers:

    &gt;&gt;&gt; integration.Participant = Participant

Now we'll define our work-items. First we'll define some classes:

    &gt;&gt;&gt; work_list = []

    &gt;&gt;&gt; class ApplicationBase:
    ...     zope.component.adapts(interfaces.IParticipant)
    ...     zope.interface.implements(interfaces.IWorkItem)
    ...
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...         work_list.append(self)
    ...
    ...     def start(self):
    ...         pass
    ...
    ...     def finish(self):
    ...         self.participant.activity.workItemFinished(self)

    &gt;&gt;&gt; class Review(ApplicationBase):
    ...     def finish(self, publish):
    ...         self.participant.activity.workItemFinished(self, publish)

    &gt;&gt;&gt; class Publish(ApplicationBase):
    ...     def start(self):
    ...         print "Published"
    ...         self.finish()

    &gt;&gt;&gt; class Reject(ApplicationBase):
    ...     def start(self):
    ...         print "Rejected"
    ...         self.finish()

and then we'll hook them up with the integration object:

    &gt;&gt;&gt; integration.authorWorkItem  = ApplicationBase
    &gt;&gt;&gt; integration.reviewWorkItem  = Review
    &gt;&gt;&gt; integration.publishWorkItem = Publish
    &gt;&gt;&gt; integration.rejectWorkItem  = Reject

Using workflow processes
------------------------

To use a process definition, instantiate it and call its start method
to start execution:

    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start()
    ... # doctest: +NORMALIZE_WHITESPACE
    ProcessStarted(Process('sample'))
    Transition(None, Activity('sample.author'))
    ActivityStarted(Activity('sample.author'))

We transition into the author activity and wait for work to get done.
To move forward, we need to get at the authoring work item, so we can
finish it.  Our work items add themselves to a work list, so we can
get the item from the list.

    &gt;&gt;&gt; item = work_list.pop()

Now we can finish the work item, by calling its finish method:

    &gt;&gt;&gt; item.finish()
    WorkItemFinished('author')
    ActivityFinished(Activity('sample.author'))
    Transition(Activity('sample.author'), Activity('sample.review'))
    ActivityStarted(Activity('sample.review'))

We see that we transitioned to the review activity.  Note that the
`finish` method isn't a part of the workflow APIs.  It was defined by
our sample classes. Other applications could use different mechanisms.

Now, we'll finish the review process by calling the review work item's
`finish`. We'll pass `False`, indicating that the content should not
be published:

    &gt;&gt;&gt; work_list.pop().finish(False)
    WorkItemFinished('review')
    ActivityFinished(Activity('sample.review'))
    Transition(Activity('sample.review'), Activity('sample.reject'))
    ActivityStarted(Activity('sample.reject'))
    Rejected
    WorkItemFinished('reject')
    ActivityFinished(Activity('sample.reject'))
    ProcessFinished(Process('sample'))

Ordering output transitions
---------------------------

Normally, outgoing transitions are ordered in the order of transition
definition and all transitions from a given activity are used.

If transitions are defined in an inconvenient order, then the workflow
might not work as expected.  For example, let's modify the above
process by switching the order of definition of some of the
transitions.  We'll reuse our integration object from the previous
example by passing it to the definition constructor:

    &gt;&gt;&gt; pd = process.ProcessDefinition('sample', integration)
    &gt;&gt;&gt; zope.component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineActivities(
    ...     author = process.ActivityDefinition(),
    ...     review = process.ActivityDefinition(),
    ...     publish = process.ActivityDefinition(),
    ...     reject = process.ActivityDefinition(),
    ...     )
    &gt;&gt;&gt; pd.defineTransitions(
    ...     process.TransitionDefinition('author', 'review'),
    ...     process.TransitionDefinition('review', 'reject'),
    ...     process.TransitionDefinition(
    ...         'review', 'publish', condition=lambda data: data.publish),
    ...     )

    &gt;&gt;&gt; pd.defineApplications(
    ...     author = process.Application(),
    ...     review = process.Application(
    ...         process.OutputParameter('publish')),
    ...     publish = process.Application(),
    ...     reject = process.Application(),
    ...     )

    &gt;&gt;&gt; pd.activities['author'].addApplication('author')
    &gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])
    &gt;&gt;&gt; pd.activities['publish'].addApplication('publish')
    &gt;&gt;&gt; pd.activities['reject'].addApplication('reject')

    &gt;&gt;&gt; pd.defineParticipants(
    ...     author   = process.Participant(),
    ...     reviewer = process.Participant(),
    ...     )

    &gt;&gt;&gt; pd.activities['author'].definePerformer('author')
    &gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')

and run our process:

    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start()
    ... # doctest: +NORMALIZE_WHITESPACE
    ProcessStarted(Process('sample'))
    Transition(None, Activity('sample.author'))
    ActivityStarted(Activity('sample.author'))

    &gt;&gt;&gt; work_list.pop().finish()
    WorkItemFinished('author')
    ActivityFinished(Activity('sample.author'))
    Transition(Activity('sample.author'), Activity('sample.review'))
    ActivityStarted(Activity('sample.review'))

This time, we'll say that we should publish:

    &gt;&gt;&gt; work_list.pop().finish(True)
    WorkItemFinished('review')
    ActivityFinished(Activity('sample.review'))
    Transition(Activity('sample.review'), Activity('sample.reject'))
    ActivityStarted(Activity('sample.reject'))
    Rejected
    WorkItemFinished('reject')
    ActivityFinished(Activity('sample.reject'))
    ProcessFinished(Process('sample'))

But we went to the reject activity anyway. Why? Because transitions
are tested in order. Because the transition to the reject activity was
tested first and had no condition, we followed it without checking the
condition for the transition to the publish activity.  We can fix this
by specifying outgoing transitions on the reviewer activity directly.
To do this, we'll also need to specify ids in our transitions.  Let's
redefine the process:


    &gt;&gt;&gt; pd = process.ProcessDefinition('sample', integration)
    &gt;&gt;&gt; zope.component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineActivities(
    ...     author = process.ActivityDefinition(),
    ...     review = process.ActivityDefinition(),
    ...     publish = process.ActivityDefinition(),
    ...     reject = process.ActivityDefinition(),
    ...     )
    &gt;&gt;&gt; pd.defineTransitions(
    ...     process.TransitionDefinition('author', 'review'),
    ...     process.TransitionDefinition('review', 'reject', id='reject'),
    ...     process.TransitionDefinition(
    ...         'review', 'publish', id='publish',
    ...         condition=lambda data: data.publish),
    ...     )

    &gt;&gt;&gt; pd.defineApplications(
    ...     author = process.Application(),
    ...     review = process.Application(
    ...         process.OutputParameter('publish')),
    ...     publish = process.Application(),
    ...     reject = process.Application(),
    ...     )

    &gt;&gt;&gt; pd.activities['author'].addApplication('author')
    &gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])
    &gt;&gt;&gt; pd.activities['publish'].addApplication('publish')
    &gt;&gt;&gt; pd.activities['reject'].addApplication('reject')

    &gt;&gt;&gt; pd.defineParticipants(
    ...     author   = process.Participant(),
    ...     reviewer = process.Participant(),
    ...     )

    &gt;&gt;&gt; pd.activities['author'].definePerformer('author')
    &gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')

    &gt;&gt;&gt; pd.activities['review'].addOutgoing('publish')
    &gt;&gt;&gt; pd.activities['review'].addOutgoing('reject')

Now, when we run the process, we'll go to the publish activity as
expected:


    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start()
    ... # doctest: +NORMALIZE_WHITESPACE
    ProcessStarted(Process('sample'))
    Transition(None, Activity('sample.author'))
    ActivityStarted(Activity('sample.author'))

    &gt;&gt;&gt; work_list.pop().finish()
    WorkItemFinished('author')
    ActivityFinished(Activity('sample.author'))
    Transition(Activity('sample.author'), Activity('sample.review'))
    ActivityStarted(Activity('sample.review'))

    &gt;&gt;&gt; work_list.pop().finish(True)
    WorkItemFinished('review')
    ActivityFinished(Activity('sample.review'))
    Transition(Activity('sample.review'), Activity('sample.publish'))
    ActivityStarted(Activity('sample.publish'))
    Published
    WorkItemFinished('publish')
    ActivityFinished(Activity('sample.publish'))
    ProcessFinished(Process('sample'))


Let's see the other way also, where we should transition to reject:


    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start()
    ... # doctest: +NORMALIZE_WHITESPACE
    ProcessStarted(Process('sample'))
    Transition(None, Activity('sample.author'))
    ActivityStarted(Activity('sample.author'))

    &gt;&gt;&gt; work_list.pop().finish()
    WorkItemFinished('author')
    ActivityFinished(Activity('sample.author'))
    Transition(Activity('sample.author'), Activity('sample.review'))
    ActivityStarted(Activity('sample.review'))

    &gt;&gt;&gt; work_list.pop().finish(False)
    WorkItemFinished('review')
    ActivityFinished(Activity('sample.review'))
    Transition(Activity('sample.review'), Activity('sample.reject'))
    ActivityStarted(Activity('sample.reject'))
    Rejected
    WorkItemFinished('reject')
    ActivityFinished(Activity('sample.reject'))
    ProcessFinished(Process('sample'))


Complex Flows
-------------

Lets look at a more complex example.  In this example, we'll extend
the process to work with multiple reviewers.  We'll also make the
work-list handling a bit more sophisticated.  We'll also introduce
some new concepts:

- splits and joins

- process arguments

Consider the publication
process shown below::


  Author:      Tech          Tech          Editorial
               Reviewer 1:   Reviewer 2:   Reviewer:
  ===========  ===========   ===========   ==============
                                                           ---------
       ----------------------------------------------------| Start |
      /                                                    ---------
      |
      V
  -----------
  | Prepare |&lt;------------------------------\
  -----------                                \
      |        ------------                   \
      |        | Tech     |--------------- \   \
      |-------&gt;| Review 1 |                 V   |
      |        ------------  ----------    -------------
       \                     | Tech   |    | Editorial |   ----------
         -------------------&gt;| Review |---&gt;| Review    |--&gt;| Reject |
                             | 2      |    -------------   ----------
                             ----------      |      |
  -----------                               /        \
  | Prepare |                              /          \--------\
  | Final   |&lt;----------------------------/                    |
  -----------                                                  |
     ^   |                                 ----------          V
     |    \-------------------------------&gt;| Review |      -----------
      \                                    | Final  |-----&gt;| Publish |
       ------------------------------------|        |      -----------
                                           ----------

Here we've arranged the process diagram into columns, with the
activities for each participant. We have four participants, the
author, two technical reviewers, and an editorial reviewer.  The
author prepares a draft.  The author sends the draft to *both*
technical reviewers for review.  When the technical reviews have
completed, the editorial review does an initial editorial
review. Based on the technical reviews, the editor may choose to:

- Reject the document

- Publish the document as is

- Request technical changes (based on the technical reviewers'
  comments), or

- Request editorial changes.

If technical changes are required, the work flows back to the
"Prepare" activity.  If editorial changes are necessary, then work
flows to the "Prepare Final" activity.  When the author has made the
editorial changes, work flows to "Review Final".  The editor may
request additional changes, in which case, work flows back to "Prepare
Final", otherwise, the work flows to "Publish".

This example illustrates different kinds of "joins" and "splits".  The
term "join" refers to the way incoming transitions to an activity are
handled. There are two kinds of joins: "and" and "xor".  With an "and"
join, the activity waits for each of the incoming transitions.  In
this example, the inputs to the "Editorial Review" activity form an
"and" join.  Editorial review waits until each of the technical
reviews are completed.  The rest of the joins in this example are
"xor" joins.  The activity starts on any transition into the activity.

The term "split" refers to way outgoing transitions from an activity
are handled.  Normally, exactly one transition out of an activity is
used. This is called an "xor" split.  With an "and" split, all
transitions with boolean conditions that evaluate to `True` are used.
In this example, the "Prepare" activity has an "and" split.  Work
flows simultaneously to the two technical review activities.  The rest
of the splits in this example are "xor" splits.

Lets create our new workflow process. We'll reuse our existing
integration object:

    &gt;&gt;&gt; Publication = process.ProcessDefinition('Publication')
    &gt;&gt;&gt; Publication.integration = integration
    &gt;&gt;&gt; zope.component.provideUtility(Publication, name=Publication.id)

    &gt;&gt;&gt; Publication.defineActivities(
    ...     start   = process.ActivityDefinition("Start"),
    ...     prepare = process.ActivityDefinition("Prepare"),
    ...     tech1   = process.ActivityDefinition("Technical Review 1"),
    ...     tech2   = process.ActivityDefinition("Technical Review 2"),
    ...     review  = process.ActivityDefinition("Editorial Review"),
    ...     final   = process.ActivityDefinition("Final Preparation"),
    ...     rfinal  = process.ActivityDefinition("Review Final"),
    ...     publish = process.ActivityDefinition("Publish"),
    ...     reject  = process.ActivityDefinition("Reject"),
    ...     )

Here, we've passed strings to the activity definitions providing
names. Names must be either unicode or ASCII strings.

We define our transitions:

    &gt;&gt;&gt; Publication.defineTransitions(
    ...     process.TransitionDefinition('start', 'prepare'),
    ...     process.TransitionDefinition('prepare', 'tech1'),
    ...     process.TransitionDefinition('prepare', 'tech2'),
    ...     process.TransitionDefinition('tech1', 'review'),
    ...     process.TransitionDefinition('tech2', 'review'),
    ...
    ...     process.TransitionDefinition(
    ...         'review', 'reject',
    ...         condition=lambda data: not data.publish
    ...         ),
    ...     process.TransitionDefinition(
    ...         'review', 'prepare',
    ...         condition=lambda data: data.tech_changes
    ...         ),
    ...     process.TransitionDefinition(
    ...         'review', 'final',
    ...         condition=lambda data: data.ed_changes
    ...         ),
    ...     process.TransitionDefinition('review', 'publish'),
    ...
    ...     process.TransitionDefinition('final', 'rfinal'),
    ...     process.TransitionDefinition(
    ...         'rfinal', 'final',
    ...         condition=lambda data: data.ed_changes
    ...         ),
    ...     process.TransitionDefinition('rfinal', 'publish'),
    ...     )

We specify our "and" split and join:

    &gt;&gt;&gt; Publication.activities['prepare'].andSplit(True)
    &gt;&gt;&gt; Publication.activities['review'].andJoin(True)

We define our participants and applications:

    &gt;&gt;&gt; Publication.defineParticipants(
    ...     author   = process.Participant("Author"),
    ...     tech1    = process.Participant("Technical Reviewer 1"),
    ...     tech2    = process.Participant("Technical Reviewer 2"),
    ...     reviewer = process.Participant("Editorial Reviewer"),
    ...     )

    &gt;&gt;&gt; Publication.defineApplications(
    ...     prepare = process.Application(),
    ...     tech_review = process.Application(
    ...         process.OutputParameter('publish'),
    ...         process.OutputParameter('tech_changes'),
    ...         ),
    ...     ed_review = process.Application(
    ...         process.InputParameter('publish1'),
    ...         process.InputParameter('tech_changes1'),
    ...         process.InputParameter('publish2'),
    ...         process.InputParameter('tech_changes2'),
    ...         process.OutputParameter('publish'),
    ...         process.OutputParameter('tech_changes'),
    ...         process.OutputParameter('ed_changes'),
    ...         ),
    ...     publish = process.Application(),
    ...     reject = process.Application(),
    ...     final = process.Application(),
    ...     rfinal = process.Application(
    ...         process.OutputParameter('ed_changes'),
    ...         ),
    ...     )

    &gt;&gt;&gt; Publication.activities['prepare'].definePerformer('author')
    &gt;&gt;&gt; Publication.activities['prepare'].addApplication('prepare')

    &gt;&gt;&gt; Publication.activities['tech1'].definePerformer('tech1')
    &gt;&gt;&gt; Publication.activities['tech1'].addApplication(
    ...     'tech_review', ['publish1', 'tech_changes1'])

    &gt;&gt;&gt; Publication.activities['tech2'].definePerformer('tech2')
    &gt;&gt;&gt; Publication.activities['tech2'].addApplication(
    ...     'tech_review', ['publish2', 'tech_changes2'])

    &gt;&gt;&gt; Publication.activities['review'].definePerformer('reviewer')
    &gt;&gt;&gt; Publication.activities['review'].addApplication(
    ...     'ed_review',
    ...     ['publish1', 'tech_changes1', 'publish2', 'tech_changes2',
    ...      'publish', 'tech_changes', 'ed_changes'],
    ...     )

    &gt;&gt;&gt; Publication.activities['final'].definePerformer('author')
    &gt;&gt;&gt; Publication.activities['final'].addApplication('final')

    &gt;&gt;&gt; Publication.activities['rfinal'].definePerformer('reviewer')
    &gt;&gt;&gt; Publication.activities['rfinal'].addApplication(
    ...     'rfinal', ['ed_changes'],
    ...     )

    &gt;&gt;&gt; Publication.activities['publish'].addApplication('publish')
    &gt;&gt;&gt; Publication.activities['reject'].addApplication('reject')

We want to be able to specify an author when we start the process.
We'd also like to be told the final disposition of the process.  To
accomplish this, we'll define parameters for our process:

    &gt;&gt;&gt; Publication.defineParameters(
    ...     process.InputParameter('author'),
    ...     process.OutputParameter('publish'),
    ...     )

Now that we've defined the process, we need to provide participant and
application components.  Let's start with our participants.  Rather
than sharing a single work list, we'll give each user their own
work list.  We'll also create preexisting participants and return
them. Finally, we'll create multiple authors and use the selected one:


    &gt;&gt;&gt; class User:
    ...     def __init__(self):
    ...         self.work_list = []

    &gt;&gt;&gt; authors = {'bob': User(), 'ted': User(), 'sally': User()}

    &gt;&gt;&gt; reviewer = User()
    &gt;&gt;&gt; tech1 = User()
    &gt;&gt;&gt; tech2 = User()

    &gt;&gt;&gt; class Author(Participant):
    ...     def __init__(self, activity):
    ...         Participant.__init__(self, activity)
    ...         author_name = activity.process.workflowRelevantData.author
    ...         print "Author `%s` selected" % author_name
    ...         self.user = authors[author_name]

In this example, we need to define a separate attribute for each participant:

    &gt;&gt;&gt; integration.authorParticipant = Author

When the process is created, the author name will be passed in and
assigned to the workflow-relevant data.  Our author class uses this
information to select the named user.

    &gt;&gt;&gt; class Reviewer(Participant):
    ...     user = reviewer
    &gt;&gt;&gt; integration.reviewerParticipant = Reviewer

    &gt;&gt;&gt; class Tech1(Participant):
    ...     user = tech1
    &gt;&gt;&gt; integration.tech1Participant = Tech1

    &gt;&gt;&gt; class Tech2(Participant):
    ...     user = tech2
    &gt;&gt;&gt; integration.tech2Participant = Tech2

We'll use our orginal participation class for activities without
performers:

    &gt;&gt;&gt; integration.Participant = Participant

Now we'll create our applications. Let's start with our author:

    &gt;&gt;&gt; class ApplicationBase(object):
    ...     zope.component.adapts(interfaces.IParticipant)
    ...     zope.interface.implements(interfaces.IWorkItem)
    ...
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...         self.activity = participant.activity
    ...         participant.user.work_list.append(self)
    ...
    ...     def start(self):
    ...         pass
    ...
    ...     def finish(self):
    ...         self.participant.activity.workItemFinished(self)

    &gt;&gt;&gt; class Prepare(ApplicationBase):
    ...
    ...     def summary(self):
    ...         process = self.activity.process
    ...         doc = getattr(process.applicationRelevantData, 'doc', '')
    ...         if doc:
    ...             print 'Previous draft:'
    ...             print doc
    ...             print 'Changes we need to make:'
    ...             for change in process.workflowRelevantData.tech_changes:
    ...                 print change
    ...         else:
    ...             print 'Please write the initial draft'
    ...
    ...     def finish(self, doc):
    ...         self.activity.process.applicationRelevantData.doc = doc
    ...         super(Prepare, self).finish()

    &gt;&gt;&gt; integration.prepareWorkItem = Prepare

Since we used the prepare application for revisions as well as initial
preparation, we provide a summary method to show us what we have to do.

Here we get the document created by the author passed in as an
argument to the finish method.  In a more realistic implementation,
the author task would create the document at the start of the task and
provide a user interface for the user to edit it.  We store the
document as application-relevant data, since we'll want reviewers to
be able to access it, but we don't need it directly for workflow
control.

    &gt;&gt;&gt; class TechReview(ApplicationBase):
    ...
    ...     def getDoc(self):
    ...         return self.activity.process.applicationRelevantData.doc
    ...
    ...     def finish(self, decision, changes):
    ...         self.activity.workItemFinished(self, decision, changes)

    &gt;&gt;&gt; integration.tech_reviewWorkItem = TechReview

Here, we provided a method to access the original document.

    &gt;&gt;&gt; class Review(TechReview):
    ...
    ...     def start(self, publish1, changes1, publish2, changes2):
    ...         if not (publish1 and publish2):
    ...             # Reject if either tech reviewer rejects
    ...             self.activity.workItemFinished(
    ...                 self, False, changes1 + changes2, ())
    ...
    ...         if changes1 or changes2:
    ...             # we won't do anything if there are tech changes
    ...             self.activity.workItemFinished(
    ...                 self, True, changes1 + changes2, ())
    ...
    ...     def finish(self, ed_changes):
    ...         self.activity.workItemFinished(self, True, (), ed_changes)

    &gt;&gt;&gt; integration.ed_reviewWorkItem = Review

In this implementation, we decided to reject outright if either
technical editor recommended rejection and to send work back to
preparation if there are any technical changes. We also subclassed
`TechReview` to get the `getDoc` method.

We'll reuse the `publish` and `reject` application from the previous
example.

    &gt;&gt;&gt; class Final(ApplicationBase):
    ...
    ...     def summary(self):
    ...         process = self.activity.process
    ...         doc = getattr(process.applicationRelevantData, 'doc', '')
    ...         print 'Previous draft:'
    ...         print self.activity.process.applicationRelevantData.doc
    ...         print 'Changes we need to make:'
    ...         for change in process.workflowRelevantData.ed_changes:
    ...            print change
    ...
    ...     def finish(self, doc):
    ...         self.activity.process.applicationRelevantData.doc = doc
    ...         super(Final, self).finish()

    &gt;&gt;&gt; integration.finalWorkItem = Final

In our this application, we simply update the document to reflect
changes.

    &gt;&gt;&gt; class ReviewFinal(TechReview):
    ...
    ...     def finish(self, ed_changes):
    ...         self.activity.workItemFinished(self, ed_changes)

    &gt;&gt;&gt; integration.rfinalWorkItem = ReviewFinal

Our process now returns data.  When we create a process, we need to
supply an object that it can call back to:

    &gt;&gt;&gt; class PublicationContext:
    ...     zope.interface.implements(interfaces.IProcessContext)
    ...
    ...     def processFinished(self, process, decision):
    ...         self.decision = decision

Now, let's try out our process:

    &gt;&gt;&gt; context = PublicationContext()
    &gt;&gt;&gt; proc = Publication(context)
    &gt;&gt;&gt; proc.start('bob')
    ProcessStarted(Process('Publication'))
    Transition(None, Activity('Publication.start'))
    ActivityStarted(Activity('Publication.start'))
    ActivityFinished(Activity('Publication.start'))
    Author `bob` selected
    Transition(Activity('Publication.start'), Activity('Publication.prepare'))
    ActivityStarted(Activity('Publication.prepare'))

We should have added an item to bob's work list. Let's get it and
finish it, submitting a document:

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.finish("I give my pledge, as an American\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my Country.")
    WorkItemFinished('prepare')
    ActivityFinished(Activity('Publication.prepare'))
    Transition(Activity('Publication.prepare'), Activity('Publication.tech1'))
    ActivityStarted(Activity('Publication.tech1'))
    Transition(Activity('Publication.prepare'), Activity('Publication.tech2'))
    ActivityStarted(Activity('Publication.tech2'))

Notice that we transitioned to *two* activities, `tech1` and
`tech2`.  This is because the prepare activity has an "and" split.
Now we'll do a tech review.  Let's see what tech1 has:

    &gt;&gt;&gt; item = tech1.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as an American
    to save, and faithfully to defend from waste
    the natural resources of my Country.

Let's tell the author to change "American" to "Earthling":

    &gt;&gt;&gt; item.finish(True, ['Change "American" to "Earthling"'])
    WorkItemFinished('tech_review')
    ActivityFinished(Activity('Publication.tech1'))
    Transition(Activity('Publication.tech1'), Activity('Publication.review'))

Here we transitioned to the editorial review activity, but we didn't
start it. This is because the editorial review activity has an "and"
join, meaning that it won't start until both transitions have
occurred.

Now we'll do the other technical review:

    &gt;&gt;&gt; item = tech2.work_list.pop()
    &gt;&gt;&gt; item.finish(True, ['Change "Country" to "planet"'])
    WorkItemFinished('tech_review')
    ActivityFinished(Activity('Publication.tech2'))
    Transition(Activity('Publication.tech2'), Activity('Publication.review'))
    ActivityStarted(Activity('Publication.review'))
    WorkItemFinished('ed_review')
    ActivityFinished(Activity('Publication.review'))
    Author `bob` selected
    Transition(Activity('Publication.review'), Activity('Publication.prepare'))
    ActivityStarted(Activity('Publication.prepare'))

Now when we transitioned to the editorial review activity, we started
it, because each of the input transitions had happened.  Our editorial
review application automatically sent the work back to preparation,
because there were technical comments. Of course the author is still `bob`.
Let's address the comments:

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.summary()
    Previous draft:
    I give my pledge, as an American
    to save, and faithfully to defend from waste
    the natural resources of my Country.
    Changes we need to make:
    Change "American" to "Earthling"
    Change "Country" to "planet"

    &gt;&gt;&gt; item.finish("I give my pledge, as an Earthling\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my planet.")
    WorkItemFinished('prepare')
    ActivityFinished(Activity('Publication.prepare'))
    Transition(Activity('Publication.prepare'), Activity('Publication.tech1'))
    ActivityStarted(Activity('Publication.tech1'))
    Transition(Activity('Publication.prepare'), Activity('Publication.tech2'))
    ActivityStarted(Activity('Publication.tech2'))

As before, after completing the initial edits, we start the technical
review activities again.  We'll review it again. This time, we have no
comments, because the author applied our requested changes:

    &gt;&gt;&gt; item = tech1.work_list.pop()
    &gt;&gt;&gt; item.finish(True, [])
    WorkItemFinished('tech_review')
    ActivityFinished(Activity('Publication.tech1'))
    Transition(Activity('Publication.tech1'), Activity('Publication.review'))

    &gt;&gt;&gt; item = tech2.work_list.pop()
    &gt;&gt;&gt; item.finish(True, [])
    WorkItemFinished('tech_review')
    ActivityFinished(Activity('Publication.tech2'))
    Transition(Activity('Publication.tech2'), Activity('Publication.review'))
    ActivityStarted(Activity('Publication.review'))

This time, we are left in the technical review activity because there
weren't any technical changes. We're ready to do our editorial review.
We'll request an editorial change:

    &gt;&gt;&gt; item = reviewer.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as an Earthling
    to save, and faithfully to defend from waste
    the natural resources of my planet.

    &gt;&gt;&gt; item.finish(['change "an" to "a"'])
    WorkItemFinished('ed_review')
    ActivityFinished(Activity('Publication.review'))
    Author `bob` selected
    Transition(Activity('Publication.review'), Activity('Publication.final'))
    ActivityStarted(Activity('Publication.final'))

Because we requested editorial changes, we transitioned to the final
editing activity, so that the author (still bob) can make the changes:

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.summary()
    Previous draft:
    I give my pledge, as an Earthling
    to save, and faithfully to defend from waste
    the natural resources of my planet.
    Changes we need to make:
    change "an" to "a"

    &gt;&gt;&gt; item.finish("I give my pledge, as a Earthling\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my planet.")
    WorkItemFinished('final')
    ActivityFinished(Activity('Publication.final'))
    Transition(Activity('Publication.final'), Activity('Publication.rfinal'))
    ActivityStarted(Activity('Publication.rfinal'))

We transition to the activity for reviewing the final edits.  We
review the document and approve it for publication:

    &gt;&gt;&gt; item = reviewer.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as a Earthling
    to save, and faithfully to defend from waste
    the natural resources of my planet.

    &gt;&gt;&gt; item.finish([])
    WorkItemFinished('rfinal')
    ActivityFinished(Activity('Publication.rfinal'))
    Transition(Activity('Publication.rfinal'), Activity('Publication.publish'))
    ActivityStarted(Activity('Publication.publish'))
    Published
    WorkItemFinished('publish')
    ActivityFinished(Activity('Publication.publish'))
    ProcessFinished(Process('Publication'))

At this point, the rest of the process finished automatically.  In
addition, the decision was recorded in the process context object:

    &gt;&gt;&gt; context.decision
    True

Coming Soon
------------

- XPDL support

- Timeouts/exceptions

- "otherwise" conditions


.. [1] There are other kinds of conditions, namely "otherwise" and
       "exception" conditions.

See also
---------
http://www.wfmc.org
http://www.wfmc.org/standards/standards.htm</t>
<t tx="sa.20080724074952.127">@language python
@tabwidth -4
@ignore
@others
if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')
</t>
<t tx="sa.20080724074952.128">##############################################################################
#
# Copyright (c) 2004 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Test hookup

$Id: tests.py 30336 2005-05-12 09:50:58Z jim $
"""
import os
import unittest
import zope.event
from zope.component import testing

</t>
<t tx="sa.20080724074952.129">def tearDown(test):
    testing.tearDown(test)
    zope.event.subscribers.pop()

</t>
<t tx="sa.20080724074952.130">def setUp(test):
    test.globs['this_directory'] = os.path.dirname(__file__)
    testing.setUp(test)

</t>
<t tx="sa.20080724074952.131">def test_multiple_input_parameters():
    """
    We'll create a very simple process that inputs two variables and
    has a single activity that just outputs them.

    &gt;&gt;&gt; from zope.wfmc import process
    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')
    &gt;&gt;&gt; from zope import component, interface
    &gt;&gt;&gt; component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineParameters(
    ...     process.InputParameter('x'),
    ...     process.InputParameter('y'),
    ...     )

    &gt;&gt;&gt; pd.defineActivities(
    ...    eek = process.ActivityDefinition(),
    ...    ook = process.ActivityDefinition(),
    ...    )

    &gt;&gt;&gt; pd.defineTransitions(process.TransitionDefinition('eek', 'ook'))

    &gt;&gt;&gt; pd.defineApplications(
    ...     eek = process.Application(
    ...         process.InputParameter('x'),
    ...         process.InputParameter('y'),
    ...         )
    ...     )

    &gt;&gt;&gt; pd.activities['eek'].addApplication('eek', ['x', 'y'])

    &gt;&gt;&gt; from zope.wfmc import interfaces

    &gt;&gt;&gt; class Participant(object):
    ...     zope.component.adapts(interfaces.IActivity)
    ...     zope.interface.implements(interfaces.IParticipant)
    ...
    ...     def __init__(self, activity):
    ...         self.activity = activity

    &gt;&gt;&gt; from zope.wfmc.attributeintegration import AttributeIntegration
    &gt;&gt;&gt; integration = AttributeIntegration()
    &gt;&gt;&gt; pd.integration = integration

    &gt;&gt;&gt; integration.Participant = Participant


    &gt;&gt;&gt; class Eek:
    ...     component.adapts(interfaces.IParticipant)
    ...     interface.implements(interfaces.IWorkItem)
    ...
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...
    ...     def start(self, x, y):
    ...         print x, y


    &gt;&gt;&gt; integration.eekWorkItem = Eek

    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start(99, 42)
    99 42


    """

</t>
<t tx="sa.20080724074952.132">def test_pickling():
    """
    &gt;&gt;&gt; from zope.wfmc import process
    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')
    &gt;&gt;&gt; from zope import component, interface
    &gt;&gt;&gt; component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineActivities(
    ...    eek = process.ActivityDefinition(),
    ...    ook = process.ActivityDefinition(),
    ...    )

    &gt;&gt;&gt; pd.defineTransitions(process.TransitionDefinition('eek', 'ook'))

    &gt;&gt;&gt; pd.defineApplications(
    ...     eek = process.Application(
    ...         process.InputParameter('x'),
    ...         process.InputParameter('y'),
    ...         )
    ...     )

    &gt;&gt;&gt; pd.activities['eek'].addApplication('eek', ['x', 'y'])


    &gt;&gt;&gt; proc = pd()

    &gt;&gt;&gt; import pickle
    &gt;&gt;&gt; s = pickle.dumps(proc)

    """

</t>
<t tx="sa.20080724074952.133">def test_inputoutput():
    """

    &gt;&gt;&gt; from zope.wfmc import process
    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')
    &gt;&gt;&gt; from zope import component, interface
    &gt;&gt;&gt; component.provideUtility(pd, name=pd.id)

    &gt;&gt;&gt; pd.defineParameters(
    ...     process.InputParameter('x'),
    ...     )

    &gt;&gt;&gt; pd.defineActivities(
    ...    eek = process.ActivityDefinition(),
    ...    ook = process.ActivityDefinition(),
    ...    )

    &gt;&gt;&gt; pd.defineTransitions(process.TransitionDefinition('eek', 'ook'))

    &gt;&gt;&gt; pd.defineApplications(
    ...     eek = process.Application(
    ...         process.InputOutputParameter('x'),
    ...         )
    ...     )

    &gt;&gt;&gt; pd.activities['eek'].addApplication('eek', ['x'])

    &gt;&gt;&gt; class Participant(object):
    ...     def __init__(self, activity):
    ...         self.activity = activity

    &gt;&gt;&gt; from zope.wfmc.attributeintegration import AttributeIntegration
    &gt;&gt;&gt; integration = AttributeIntegration()
    &gt;&gt;&gt; pd.integration = integration

    &gt;&gt;&gt; integration.Participant = Participant

    &gt;&gt;&gt; class Eek:
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...
    ...     def start(self, x):
    ...         self.participant.activity.workItemFinished(self, x+1)


    &gt;&gt;&gt; integration.eekWorkItem = Eek

    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start(1)
    &gt;&gt;&gt; proc.workflowRelevantData.x
    2

    """
</t>
<t tx="sa.20080724074952.134">def test_wrong_number_process_args_error_message():
    """

    &gt;&gt;&gt; from zope.wfmc import process
    &gt;&gt;&gt; pd = process.ProcessDefinition('sample')
    &gt;&gt;&gt; from zope import component, interface
    &gt;&gt;&gt; component.provideUtility(pd, name=pd.id)
    &gt;&gt;&gt; pd.defineActivities(
    ...    eek = process.ActivityDefinition(),
    ...    ook = process.ActivityDefinition(),
    ...    )
    &gt;&gt;&gt; pd.defineTransitions(process.TransitionDefinition('eek', 'ook'))

    &gt;&gt;&gt; proc = pd()
    &gt;&gt;&gt; proc.start(1)
    Traceback (most recent call last):
    ...
    TypeError: Too many arguments. Expected 0. got 1

    """


</t>
<t tx="sa.20080724074952.135">def test_suite():
    from zope.testing import doctest
    suite = unittest.TestSuite()
    suite.addTest(doctest.DocFileSuite('README.txt', tearDown=tearDown,
                                       setUp=testing.setUp))
    suite.addTest(doctest.DocFileSuite(
        'xpdl.txt', tearDown=tearDown, setUp=setUp,
        optionflags=doctest.NORMALIZE_WHITESPACE))
    suite.addTest(doctest.DocTestSuite(tearDown=testing.tearDown,
                                       setUp=testing.setUp))
    return suite

</t>
<t tx="sa.20080724074952.136">@language python
@tabwidth -4
@ignore
@others
</t>
<t tx="sa.20080724074952.137">##############################################################################
#
# Copyright (c) 2004 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""XPDL reader for process definitions

$Id: xpdl.py 70052 2006-09-08 12:27:59Z adamg $
"""

import sys
import xml.sax
import xml.sax.xmlreader
import xml.sax.handler

import zope.wfmc.process

xpdlns = "http://www.wfmc.org/2002/XPDL1.0"


</t>
<t tx="sa.20080724074952.138">class HandlerError(Exception):
    @others
</t>
<t tx="sa.20080724074952.139">
def __init__(self, orig, tag, locator):
    self.orig = orig
    self.tag = tag
    self.xml = locator.getSystemId()
    self.line = locator.getLineNumber()

</t>
<t tx="sa.20080724074952.140">def __repr__(self):
    return ('%r\nFile "%s", line %s. in %s'
            % (self.orig, self.xml, self.line, self.tag))

</t>
<t tx="sa.20080724074952.141">def __str__(self):
    return ('%s\nFile "%s", line %s. in %s'
            % (self.orig, self.xml, self.line, self.tag))


</t>
<t tx="sa.20080724074952.142">class Package(dict):
    @others
</t>
<t tx="sa.20080724074952.143">
def __init__(self):
    self.applications = {}
    self.participants = {}

</t>
<t tx="sa.20080724074952.144">def defineApplications(self, **applications):
    for id, application in applications.items():
        application.id = id
        self.applications[id] = application

</t>
<t tx="sa.20080724074952.145">def defineParticipants(self, **participants):
    for id, participant in participants.items():
        participant.id = id
        self.participants[id] = participant


</t>
<t tx="sa.20080724074952.146">class XPDLHandler(xml.sax.handler.ContentHandler):

    start_handlers = {}
    end_handlers = {}
    text = u''

    ProcessDefinitionFactory = zope.wfmc.process.ProcessDefinition
    ParticipantFactory = zope.wfmc.process.Participant
    ApplicationFactory = zope.wfmc.process.Application
    ActivityDefinitionFactory = zope.wfmc.process.ActivityDefinition
    TransitionDefinitionFactory = zope.wfmc.process.TransitionDefinition

    @others
    end_handlers[(xpdlns, 'Condition')] = condition


</t>
<t tx="sa.20080724074952.147">def __init__(self, package):
    self.package = package
    self.stack = []

</t>
<t tx="sa.20080724074952.148">def startElementNS(self, name, qname, attrs):
    handler = self.start_handlers.get(name)
    if handler:
        try:
            result = handler(self, attrs)
        except:
            raise HandlerError(sys.exc_info()[1], name[1], self.locator
                ), None, sys.exc_info()[2]
    else:
        result = None

    if result is None:
        # Just dup the top of the stack
        result = self.stack[-1]

    self.stack.append(result)
    self.text = u''

</t>
<t tx="sa.20080724074952.149">def endElementNS(self, name, qname):
    last = self.stack.pop()
    handler = self.end_handlers.get(name)
    if handler:
        try:
            handler(self, last)
        except:
            raise HandlerError(sys.exc_info()[1], name[1], self.locator
                ), None, sys.exc_info()[2]

    self.text = u''

</t>
<t tx="sa.20080724074952.150">def characters(self, text):
    self.text += text

</t>
<t tx="sa.20080724074952.151">def setDocumentLocator(self, locator):
    self.locator = locator

</t>
<t tx="sa.20080724074952.152">######################################################################
# Application handlers

# Pointless container elements that we want to "ignore" by having them
# dup their containers:
def Package(self, attrs):
    package = self.package
    package.id = attrs[(None, 'Id')]
    package.__name__ = attrs.get((None, 'Name'))
    return package
</t>
<t tx="sa.20080724074952.153">start_handlers[(xpdlns, 'Package')] = Package

def WorkflowProcess(self, attrs):
    id = attrs[(None, 'Id')]
    process = self.ProcessDefinitionFactory(id)
    process.__name__ = attrs.get((None, 'Name'))

    # Copy package data:
    process.defineApplications(**self.package.applications)
    process.defineParticipants(**self.package.participants)

    self.package[id] = process
    return process
</t>
<t tx="sa.20080724074952.154">start_handlers[(xpdlns, 'WorkflowProcess')] = WorkflowProcess

paramter_types = {
    'IN': zope.wfmc.process.InputParameter,
    'OUT': zope.wfmc.process.OutputParameter,
    'INOUT': zope.wfmc.process.InputOutputParameter,
    }


def FormalParameter(self, attrs):
    mode = attrs.get((None, 'Mode'), 'IN')
    id = attrs[(None, 'Id')]
    self.stack[-1].defineParameters(*[self.paramter_types[mode](id)])
</t>
<t tx="sa.20080724074952.155">start_handlers[(xpdlns, 'FormalParameter')] = FormalParameter

def Participant(self, attrs):
    id = attrs[(None, 'Id')]
    name = attrs.get((None, 'Name'))
    participant = self.ParticipantFactory(name)
    self.stack[-1].defineParticipants(**{str(id): participant})
    return participant
</t>
<t tx="sa.20080724074952.156">start_handlers[(xpdlns, 'Participant')] = Participant

def Application(self, attrs):
    id = attrs[(None, 'Id')]
    name = attrs.get((None, 'Name'))
    app = self.ApplicationFactory()
    app.id = id
    if name:
        app.__name__ = name
    return app
</t>
<t tx="sa.20080724074952.157">start_handlers[(xpdlns, 'Application')] = Application

def application(self, app):
    self.stack[-1].defineApplications(**{str(app.id): app})
</t>
<t tx="sa.20080724074952.158">end_handlers[(xpdlns, 'Application')] = application

def description(self, ignored):
    if self.stack[-1] is not None:
        self.stack[-1].description = self.text
</t>
<t tx="sa.20080724074952.159">end_handlers[(xpdlns, 'Description')] = description

######################################################################
# Activity definitions

def ActivitySet(self, attrs):
    raise NotImplementedError("ActivitySet")
</t>
<t tx="sa.20080724074952.160">end_handlers[(xpdlns, 'ActivitySet')] = ActivitySet

def Activity(self, attrs):
    id = attrs[(None, 'Id')]
    name = attrs.get((None, 'Name'))
    activity = self.ActivityDefinitionFactory(name)
    activity.id = id
    self.stack[-1].defineActivities(**{str(id): activity})
    return activity
</t>
<t tx="sa.20080724074952.161">start_handlers[(xpdlns, 'Activity')] = Activity

def Tool(self, attrs):
    return Tool(attrs[(None, 'Id')])
</t>
<t tx="sa.20080724074952.162">start_handlers[(xpdlns, 'Tool')] = Tool

def tool(self, tool):
    self.stack[-1].addApplication(tool.id, tool.parameters)
</t>
<t tx="sa.20080724074952.163">end_handlers[(xpdlns, 'Tool')] = tool

def actualparameter(self, ignored):
    self.stack[-1].parameters += (self.text, )
</t>
<t tx="sa.20080724074952.164">end_handlers[(xpdlns, 'ActualParameter')] = actualparameter

def performer(self, ignored):
    self.stack[-1].definePerformer(self.text.strip())
</t>
<t tx="sa.20080724074952.165">end_handlers[(xpdlns, 'Performer')] = performer

def Join(self, attrs):
    Type = attrs.get((None, 'Type'))
    if Type == u'AND':
        self.stack[-1].andJoin(True)
</t>
<t tx="sa.20080724074952.166">start_handlers[(xpdlns, 'Join')] = Join

def Split(self, attrs):
    Type = attrs.get((None, 'Type'))
    if Type == u'AND':
        self.stack[-1].andSplit(True)
</t>
<t tx="sa.20080724074952.167">start_handlers[(xpdlns, 'Split')] = Split

def TransitionRef(self, attrs):
    Id = attrs.get((None, 'Id'))
    self.stack[-1].addOutgoing(Id)
</t>
<t tx="sa.20080724074952.168">start_handlers[(xpdlns, 'TransitionRef')] = TransitionRef


# Activity definitions
######################################################################

def Transition(self, attrs):
    id = attrs[(None, 'Id')]
    name = attrs.get((None, 'Name'))
    from_ = attrs.get((None, 'From'))
    to = attrs.get((None, 'To'))
    transition = self.TransitionDefinitionFactory(from_, to)
    transition.id = id
    transition.__name__ = name
    return transition
</t>
<t tx="sa.20080724074952.169">start_handlers[(xpdlns, 'Transition')] = Transition

def transition(self, transition):
    self.stack[-1].defineTransitions(transition)
</t>
<t tx="sa.20080724074952.170">end_handlers[(xpdlns, 'Transition')] = transition

def condition(self, ignored):
    assert isinstance(self.stack[-1],
                      self.TransitionDefinitionFactory)

    text = self.text
    self.stack[-1].condition = TextCondition("(%s)" % text)
</t>
<t tx="sa.20080724074952.171">class Tool:
    @others
    parameters = ()

</t>
<t tx="sa.20080724074952.172">
def __init__(self, id):
    self.id = id

</t>
<t tx="sa.20080724074952.173">class TextCondition:
    @others
</t>
<t tx="sa.20080724074952.174">
def __init__(self, source):
    self.source = source

    # make sure that we can compile the source
    compile(source, '&lt;string&gt;', 'eval')

</t>
<t tx="sa.20080724074952.175">def __getstate__(self):
    return {'source': self.source}

</t>
<t tx="sa.20080724074952.176">def __call__(self, data):
    # We *depend* on being able to use the data's dict.
    # TODO This needs to be part of the contract.
    try:
        compiled = self._v_compiled
    except AttributeError:
        self._v_compiled = compile(self.source, '&lt;string&gt;', 'eval')
        compiled = self._v_compiled

    return eval(compiled, {'__builtins__': None}, data.__dict__)


</t>
<t tx="sa.20080724074952.177">def read(file):
    src = xml.sax.xmlreader.InputSource(getattr(file, 'name', '&lt;string&gt;'))
    src.setByteStream(file)
    parser = xml.sax.make_parser()
    package = Package()
    parser.setContentHandler(XPDLHandler(package))
    parser.setFeature(xml.sax.handler.feature_namespaces, True)
    parser.parse(src)
    return package

</t>
<t tx="sa.20080724074952.178">@ignore
@nocolor
===========
XPDL Import
===========

We can import process definitions from files in the XML Process
Definition Language (XPDL) format. An XPDL file contains multiple
process definitions arranged in a package. When we load the file, we
get a package containing some number of process definitions.

Let's look at an example.  The file `publication.xpdl`
contains a definition for the publication example developed in the
"README.txt" file.  We can read it using the xpdl module:

    &gt;&gt;&gt; from zope.wfmc import xpdl
    &gt;&gt;&gt; import os
    &gt;&gt;&gt; package = xpdl.read(open(os.path.join(this_directory,
    ...                                       'publication.xpdl')))

This package contains a single definition:

    &gt;&gt;&gt; package
    {u'Publication': ProcessDefinition(u'Publication')}

    &gt;&gt;&gt; pd = package[u'Publication']
    &gt;&gt;&gt; from zope.wfmc.attributeintegration import AttributeIntegration
    &gt;&gt;&gt; integration = AttributeIntegration()
    &gt;&gt;&gt; pd.integration = integration

Now, having read the process definition, we can use it as we did
before (in "README.txt").  As before, we'll create an event subscriber
so that we can see what's going on:

    &gt;&gt;&gt; def log_workflow(event):
    ...     print event

    &gt;&gt;&gt; import zope.event
    &gt;&gt;&gt; zope.event.subscribers.append(log_workflow)

and we'll register the process definition as a utility:

    &gt;&gt;&gt; import zope.component
    &gt;&gt;&gt; zope.component.provideUtility(pd, name=pd.id)

and we'll define and register participant and application adapters:

    &gt;&gt;&gt; import zope.interface
    &gt;&gt;&gt; from zope.wfmc import interfaces

    &gt;&gt;&gt; class Participant(object):
    ...     zope.component.adapts(interfaces.IActivity)
    ...     zope.interface.implements(interfaces.IParticipant)
    ...
    ...     def __init__(self, activity):
    ...         self.activity = activity

    &gt;&gt;&gt; class User:
    ...     def __init__(self):
    ...         self.work_list = []

    &gt;&gt;&gt; authors = {'bob': User(), 'ted': User(), 'sally': User()}

    &gt;&gt;&gt; reviewer = User()
    &gt;&gt;&gt; tech1 = User()
    &gt;&gt;&gt; tech2 = User()

    &gt;&gt;&gt; class Author(Participant):
    ...     def __init__(self, activity):
    ...         Participant.__init__(self, activity)
    ...         author_name = activity.process.workflowRelevantData.author
    ...         print "Author `%s` selected" % author_name
    ...         self.user = authors[author_name]

    &gt;&gt;&gt; integration.authorParticipant = Author

    &gt;&gt;&gt; class Reviewer(Participant):
    ...     user = reviewer
    &gt;&gt;&gt; integration.reviewerParticipant = Reviewer

    &gt;&gt;&gt; class Tech1(Participant):
    ...     user = tech1
    &gt;&gt;&gt; integration.tech1Participant = Tech1

    &gt;&gt;&gt; class Tech2(Participant):
    ...     user = tech2
    &gt;&gt;&gt; integration.tech2Participant = Tech2

    &gt;&gt;&gt; integration.SystemParticipant = Participant

    &gt;&gt;&gt; class ApplicationBase(object):
    ...     zope.component.adapts(interfaces.IParticipant)
    ...     zope.interface.implements(interfaces.IWorkItem)
    ...
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...         self.activity = participant.activity
    ...         participant.user.work_list.append(self)
    ...
    ...     def start(self):
    ...         pass
    ...
    ...     def finish(self):
    ...         self.participant.activity.workItemFinished(self)

    &gt;&gt;&gt; class Prepare(ApplicationBase):
    ...
    ...     def summary(self):
    ...         process = self.activity.process
    ...         doc = getattr(process.applicationRelevantData, 'doc', '')
    ...         if doc:
    ...             print 'Previous draft:'
    ...             print doc
    ...             print 'Changes we need to make:'
    ...             for change in process.workflowRelevantData.tech_changes:
    ...                 print change
    ...         else:
    ...             print 'Please write the initial draft'
    ...
    ...     def finish(self, doc):
    ...         self.activity.process.applicationRelevantData.doc = doc
    ...         super(Prepare, self).finish()

    &gt;&gt;&gt; integration.prepareWorkItem = Prepare

    &gt;&gt;&gt; class TechReview(ApplicationBase):
    ...
    ...     def getDoc(self):
    ...         return self.activity.process.applicationRelevantData.doc
    ...
    ...     def finish(self, decision, changes):
    ...         self.activity.workItemFinished(self, decision, changes)

    &gt;&gt;&gt; integration.tech_reviewWorkItem = TechReview

    &gt;&gt;&gt; class Review(TechReview):
    ...
    ...     def start(self, publish1, changes1, publish2, changes2):
    ...         if not (publish1 and publish2):
    ...             # Reject if either tech reviewer rejects
    ...             self.activity.workItemFinished(
    ...                 self, False, changes1 + changes2, ())
    ...
    ...         if changes1 or changes2:
    ...             # we won't do anyting if there are tech changes
    ...             self.activity.workItemFinished(
    ...                 self, True, changes1 + changes2, ())
    ...
    ...     def finish(self, ed_changes):
    ...         self.activity.workItemFinished(self, True, (), ed_changes)

    &gt;&gt;&gt; integration.ed_reviewWorkItem = Review

    &gt;&gt;&gt; class Final(ApplicationBase):
    ...
    ...     def summary(self):
    ...         process = self.activity.process
    ...         doc = getattr(process.applicationRelevantData, 'doc', '')
    ...         print 'Previous draft:'
    ...         print self.activity.process.applicationRelevantData.doc
    ...         print 'Changes we need to make:'
    ...         for change in process.workflowRelevantData.ed_changes:
    ...            print change
    ...
    ...     def finish(self, doc):
    ...         self.activity.process.applicationRelevantData.doc = doc
    ...         super(Final, self).finish()

    &gt;&gt;&gt; integration.finalWorkItem = Final

    &gt;&gt;&gt; class ReviewFinal(TechReview):
    ...
    ...     def finish(self, ed_changes):
    ...         self.activity.workItemFinished(self, ed_changes)

    &gt;&gt;&gt; integration.rfinalWorkItem = ReviewFinal


    &gt;&gt;&gt; class Publish:
    ...     zope.component.adapts(interfaces.IParticipant)
    ...     zope.interface.implements(interfaces.IWorkItem)
    ...
    ...     def __init__(self, participant):
    ...         self.participant = participant
    ...
    ...     def start(self):
    ...         print "Published"
    ...         self.finish()
    ...
    ...     def finish(self):
    ...         self.participant.activity.workItemFinished(self)


    &gt;&gt;&gt; integration.publishWorkItem = Publish

    &gt;&gt;&gt; class Reject(Publish):
    ...     def start(self):
    ...         print "Rejected"
    ...         self.finish()

    &gt;&gt;&gt; integration.rejectWorkItem = Reject

and a process context, so we can pass parameters:

    &gt;&gt;&gt; class PublicationContext:
    ...     zope.interface.implements(interfaces.IProcessContext)
    ...
    ...     def processFinished(self, process, decision):
    ...         self.decision = decision

Now, let's try out our process.  We'll follow the same steps we did in
"README.txt", getting the same results:

    &gt;&gt;&gt; context = PublicationContext()
    &gt;&gt;&gt; proc = pd(context)
    &gt;&gt;&gt; proc.start('bob')
    ProcessStarted(Process(u'Publication'))
    Transition(None, Activity(u'Publication.start'))
    ActivityStarted(Activity(u'Publication.start'))
    ActivityFinished(Activity(u'Publication.start'))
    Author `bob` selected
    Transition(Activity(u'Publication.start'),
               Activity(u'Publication.prepare'))
    ActivityStarted(Activity(u'Publication.prepare'))

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.finish("I give my pledge, as an American\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my Country.")
    WorkItemFinished(u'prepare')
    ActivityFinished(Activity(u'Publication.prepare'))
    Transition(Activity(u'Publication.prepare'),
               Activity(u'Publication.tech1'))
    ActivityStarted(Activity(u'Publication.tech1'))
    Transition(Activity(u'Publication.prepare'),
               Activity(u'Publication.tech2'))
    ActivityStarted(Activity(u'Publication.tech2'))

    &gt;&gt;&gt; item = tech1.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as an American
    to save, and faithfully to defend from waste
    the natural resources of my Country.

    &gt;&gt;&gt; item.finish(True, ['Change "American" to "human"'])
    WorkItemFinished(u'tech_review')
    ActivityFinished(Activity(u'Publication.tech1'))
    Transition(Activity(u'Publication.tech1'),
               Activity(u'Publication.review'))

    &gt;&gt;&gt; item = tech2.work_list.pop()
    &gt;&gt;&gt; item.finish(True, ['Change "Country" to "planet"'])
    WorkItemFinished(u'tech_review')
    ActivityFinished(Activity(u'Publication.tech2'))
    Transition(Activity(u'Publication.tech2'),
               Activity(u'Publication.review'))
    ActivityStarted(Activity(u'Publication.review'))
    WorkItemFinished(u'ed_review')
    ActivityFinished(Activity(u'Publication.review'))
    Author `bob` selected
    Transition(Activity(u'Publication.review'),
               Activity(u'Publication.prepare'))
    ActivityStarted(Activity(u'Publication.prepare'))

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.summary()
    Previous draft:
    I give my pledge, as an American
    to save, and faithfully to defend from waste
    the natural resources of my Country.
    Changes we need to make:
    Change "American" to "human"
    Change "Country" to "planet"

    &gt;&gt;&gt; item.finish("I give my pledge, as an human\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my planet.")
    WorkItemFinished(u'prepare')
    ActivityFinished(Activity(u'Publication.prepare'))
    Transition(Activity(u'Publication.prepare'),
               Activity(u'Publication.tech1'))
    ActivityStarted(Activity(u'Publication.tech1'))
    Transition(Activity(u'Publication.prepare'),
               Activity(u'Publication.tech2'))
    ActivityStarted(Activity(u'Publication.tech2'))

    &gt;&gt;&gt; item = tech1.work_list.pop()
    &gt;&gt;&gt; item.finish(True, [])
    WorkItemFinished(u'tech_review')
    ActivityFinished(Activity(u'Publication.tech1'))
    Transition(Activity(u'Publication.tech1'),
               Activity(u'Publication.review'))

    &gt;&gt;&gt; item = tech2.work_list.pop()
    &gt;&gt;&gt; item.finish(True, [])
    WorkItemFinished(u'tech_review')
    ActivityFinished(Activity(u'Publication.tech2'))
    Transition(Activity(u'Publication.tech2'),
               Activity(u'Publication.review'))
    ActivityStarted(Activity(u'Publication.review'))

    &gt;&gt;&gt; item = reviewer.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as an human
    to save, and faithfully to defend from waste
    the natural resources of my planet.

    &gt;&gt;&gt; item.finish(['change "an" to "a"'])
    WorkItemFinished(u'ed_review')
    ActivityFinished(Activity(u'Publication.review'))
    Author `bob` selected
    Transition(Activity(u'Publication.review'),
               Activity(u'Publication.final'))
    ActivityStarted(Activity(u'Publication.final'))

    &gt;&gt;&gt; item = authors['bob'].work_list.pop()
    &gt;&gt;&gt; item.summary()
    Previous draft:
    I give my pledge, as an human
    to save, and faithfully to defend from waste
    the natural resources of my planet.
    Changes we need to make:
    change "an" to "a"

    &gt;&gt;&gt; item.finish("I give my pledge, as a human\n"
    ...             "to save, and faithfully to defend from waste\n"
    ...             "the natural resources of my planet.")
    WorkItemFinished(u'final')
    ActivityFinished(Activity(u'Publication.final'))
    Transition(Activity(u'Publication.final'),
               Activity(u'Publication.rfinal'))
    ActivityStarted(Activity(u'Publication.rfinal'))

    &gt;&gt;&gt; item = reviewer.work_list.pop()
    &gt;&gt;&gt; print item.getDoc()
    I give my pledge, as a human
    to save, and faithfully to defend from waste
    the natural resources of my planet.

    &gt;&gt;&gt; item.finish([])
    WorkItemFinished(u'rfinal')
    ActivityFinished(Activity(u'Publication.rfinal'))
    Transition(Activity(u'Publication.rfinal'),
               Activity(u'Publication.publish'))
    ActivityStarted(Activity(u'Publication.publish'))
    Published
    WorkItemFinished(u'publish')
    ActivityFinished(Activity(u'Publication.publish'))
    ProcessFinished(Process(u'Publication'))

    &gt;&gt;&gt; context.decision
    True


Descriptions
------------

Most process elements can have names and descriptions.

    &gt;&gt;&gt; pd.__name__
    u'Publication'

    &gt;&gt;&gt; pd.description
    u'This is the sample process'

    &gt;&gt;&gt; pd.applications['prepare'].__name__
    u'Prepare'

    &gt;&gt;&gt; pd.applications['prepare'].description
    u'Prepare the initial draft'

    &gt;&gt;&gt; pd.activities['tech1'].__name__
    u'Technical Review 1'

    &gt;&gt;&gt; pd.activities['tech1'].description
    u'This is the first Technical Review.'

    &gt;&gt;&gt; pd.participants['tech1'].__name__
    u'Technical Reviewer 1'

    &gt;&gt;&gt; pd.participants['tech1'].description
    u'He is a smart guy.'

    &gt;&gt;&gt; sorted([item.__name__ for item in pd.transitions])
        [u'Transition', u'Transition', u'Transition', u'Transition',
        u'Transition', u'Transition', u'Transition', u'Transition',
        u'Transition', u'Transition', u'Transition to Tech Review 1',
        u'Transition to Tech Review 2']

    &gt;&gt;&gt; sorted([item.description for item in pd.transitions])
        [None, None, None, None, None, None, None, None, None, None, None,
        u'Use this transition if there are editorial changes required.']
</t>
<t tx="sa.20080726124242.1"></t>
<t tx="sa.20080726124242.2"></t>
<t tx="sa.20080727142922.1">- moved goflow.workflow.logger into goflow.utils.logger
- moved goflow.workflow.decorators into goflow.utils.decorators


</t>
<t tx="sa.20080727144116.1">

.. _goflow.instances.managers:

:mod:`goflow.instances.managers` -- managers for process_instance management 
================================================================================

.. automodule:: goflow.instances.managers 
   :synopsis: managers for process_instance management 
   :members:

</t>
</tnodes>
</leo_file>
