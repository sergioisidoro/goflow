<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="41" left="64" height="789" width="1314"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sa.20080716081317.2" str_leo_pos="1,0,1,6"><vh>startup</vh>
<v t="sa.20080714011136.1"><vh>@chapters</vh></v>
<v t="sa.20080716081317.3"><vh>Buttons</vh>
<v t="sa.20080716081317.4"><vh>@@button gendocs</vh></v>
</v>
<v t="sa.20080716081317.5"><vh>@settings</vh></v>
</v>
<v t="sa.20080714235246.1" a="E"><vh>src</vh>
<v t="sa.20080714011136.2" a="E"><vh>docs</vh>
<v t="sa.20080714012008.6"><vh>@rst index.rst</vh></v>
<v t="sa.20080714012008.2" a="E"><vh>@rst overview.rst</vh>
<v t="sa.20080714081843.1"><vh>Preface</vh></v>
<v t="sa.20080714081843.3"><vh>Summary</vh></v>
<v t="sa.20080714081843.2"><vh>Overview</vh></v>
<v t="sa.20080714081843.4"><vh>Benefits of using GoFlow</vh>
<v t="sa.20080715122316.2"><vh>To User</vh>
<v t="sa.20080714081843.5"><vh>Efficiency</vh></v>
<v t="sa.20080714081843.6"><vh>Formalisation </vh></v>
<v t="sa.20080715122316.3"><vh>Compliance</vh></v>
</v>
<v t="sa.20080715122316.4"><vh>To Developer</vh>
<v t="sa.20080717192016.4"><vh>Extensibility</vh></v>
<v t="sa.20080715122316.9"><vh>Simplicity</vh></v>
<v t="sa.20080715122316.5"><vh>Django Integration</vh></v>
<v t="sa.20080715122316.6"><vh>Python Language</vh></v>
<v t="sa.20080715122316.7"><vh>Web configuration of Workflow</vh></v>
<v t="sa.20080715122316.8"><vh>Speed of Development</vh></v>
</v>
</v>
<v t="sa.20080714081843.7"><vh>The Process Definition</vh>
<v t="sa.20080714081843.8"><vh>Activities (What)</vh></v>
<v t="sa.20080714081843.9"><vh>Transitions (When)</vh></v>
<v t="sa.20080714081843.10"><vh>Applications (How)</vh></v>
<v t="sa.20080714081843.11"><vh>Users &amp; Roles (Who)</vh></v>
</v>
<v t="sa.20080714081843.12"><vh>The Process Instance</vh>
<v t="sa.20080714081843.13"><vh>Workitems: tracking the history</vh></v>
<v t="sa.20080714081843.14"><vh>Worklist and assigning work</vh></v>
<v t="sa.20080714081843.16"><vh>Exception Handling</vh></v>
<v t="sa.20080714081843.15"><vh>Focus on Flexibility</vh></v>
<v t="sa.20080714081843.17"><vh>Dynamic Redesign</vh></v>
</v>
<v t="sa.20080714081843.18"><vh>Features</vh></v>
<v t="sa.20080714081843.19"><vh>Requirements</vh></v>
<v t="sa.20080714081843.20"><vh>Download</vh></v>
</v>
<v t="sa.20080714012008.42" a="E"><vh>@rst patterns.rst</vh>
<v t="sa.20080717192016.13"><vh>Sequence Pattern</vh>
<v t="sa.20080717192016.14"><vh>Description</vh></v>
<v t="sa.20080717192016.15"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.16"><vh>Examples</vh></v>
<v t="sa.20080717192016.17"><vh>Motivation</vh></v>
</v>
<v t="sa.20080717192016.18"><vh>XOR-Join Pattern</vh>
<v t="sa.20080717192016.19"><vh>Description</vh></v>
<v t="sa.20080717192016.20"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.21"><vh>Examples</vh></v>
<v t="sa.20080717192016.22"><vh>Motivation</vh></v>
</v>
<v t="sa.20080717192016.23"><vh>XOR-Split Pattern</vh>
<v t="sa.20080717192016.24"><vh>Description</vh></v>
<v t="sa.20080717192016.25"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.26"><vh>Examples</vh></v>
<v t="sa.20080717192016.27"><vh>Motivation</vh></v>
</v>
<v t="sa.20080714012008.44"><vh>AND-Join Pattern</vh>
<v t="sa.20080717192016.5"><vh>Description</vh></v>
<v t="sa.20080717192016.6"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.7"><vh>Examples</vh></v>
<v t="sa.20080717192016.8"><vh>Motivation</vh></v>
</v>
<v t="sa.20080714012008.45"><vh>AND-Split Pattern</vh>
<v t="sa.20080717192016.9"><vh>Description</vh></v>
<v t="sa.20080717192016.10"><vh>Synonyms</vh></v>
<v t="sa.20080717192016.11"><vh>Examples</vh></v>
<v t="sa.20080717192016.12"><vh>Motivation</vh></v>
</v>
</v>
<v t="sa.20080714012008.9"><vh>@rst install.rst</vh></v>
<v t="sa.20080714012008.5"><vh>@rst tutorials.rst</vh>
<v t="sa.20080714081843.28"><vh>Prerequisites</vh></v>
<v t="sa.20080714081843.29"><vh>Project "Hello World"</vh>
<v t="sa.20080714081843.30"><vh>Let's add an activity</vh></v>
<v t="sa.20080714081843.31"><vh>Let's add our own models</vh></v>
<v t="sa.20080714081843.32"><vh>And for some code</vh></v>
</v>
<v t="sa.20080714081843.33"><vh>Advanced Tutorial</vh>
<v t="sa.20080714081843.34"><vh>Prerequisites</vh></v>
<v t="sa.20080714081843.35"><vh>Application Unit Testing</vh></v>
<v t="sa.20080714081843.36"><vh>Application Automation</vh></v>
</v>
</v>
<v t="sa.20080714012008.3"><vh>@rst faq.rst</vh>
<v t="sa.20080714081843.21"><vh>What is this all about?</vh></v>
<v t="sa.20080714081843.22"><vh>When should I use PushApplication and when should I use Roles in Activity definition? What happens if I select both?</vh></v>
<v t="sa.20080714081843.23"><vh>What are AutoStart and AutoFinish in Activity definition</vh></v>
<v t="sa.20080714081843.25"><vh>How should I define a transition condition ?</vh></v>
<v t="sa.20080714081843.24"><vh>Is it valid to reuse Activities?</vh></v>
</v>
<v t="sa.20080714012008.7"><vh>@rst history.rst</vh>
<v t="sa.20080714081843.37"><vh>Origins</vh></v>
<v t="sa.20080714081843.38"><vh>Roadmap</vh></v>
<v t="sa.20080714081843.39"><vh>Current Status</vh></v>
<v t="sa.20080714081843.40"><vh>Future Features</vh></v>
</v>
<v t="sa.20080714012008.8"><vh>@rst definitions.rst</vh>
<v t="sa.20080715111354.1"><vh>Introduction &amp; Concepts</vh></v>
<v t="sa.20080715111354.2"><vh>Definitions</vh>
<v t="sa.20080715111354.3"><vh>Process</vh></v>
<v t="sa.20080715111354.4"><vh>Activity</vh></v>
<v t="sa.20080715111354.5"><vh>Transitions</vh></v>
<v t="sa.20080715111354.6"><vh>Role</vh></v>
<v t="sa.20080715111354.7"><vh>ProcessInstance</vh></v>
<v t="sa.20080715111354.8"><vh>WorkItem</vh></v>
</v>
<v t="sa.20080715111354.9"><vh>Activity Types</vh>
<v t="sa.20080715111354.10"><vh>Start Activity</vh></v>
<v t="sa.20080715111354.11"><vh>End Activity</vh></v>
<v t="sa.20080715111354.12"><vh>Normal Activity</vh></v>
<v t="sa.20080715111354.13"><vh>Switch Activity</vh></v>
<v t="sa.20080715111354.14"><vh>Split Activity</vh></v>
<v t="sa.20080715111354.15"><vh>Join Activity</vh></v>
<v t="sa.20080715111354.16"><vh>Standalone Activity</vh></v>
</v>
<v t="sa.20080715111354.17"><vh>AutoRouting &amp; Interactiveness</vh>
<v t="sa.20080715111354.18"><vh>AutoRouting</vh></v>
<v t="sa.20080715111354.19"><vh>Interactiveness</vh></v>
</v>
<v t="sa.20080715111354.20"><vh>Sample Process</vh></v>
<v t="sa.20080715111354.21"><vh>Modules</vh>
<v t="sa.20080715111354.22"><vh>Process Manager</vh></v>
<v t="sa.20080715111354.23"><vh>User Interface</vh></v>
<v t="sa.20080715111354.24"><vh>The Process Monitor</vh></v>
</v>
</v>
<v t="sa.20080714012008.11"><vh>@rst changes.rst</vh>
<v t="sa.20080714225902.5"><vh>Release 0.51</vh>
<v t="sa.20080714225902.6"><vh>New Features</vh></v>
<v t="sa.20080714225902.7"><vh>Bug Fixes</vh></v>
<v t="sa.20080714225902.8"><vh>Backwards Incompatible Changes</vh></v>
</v>
</v>
<v t="sa.20080714012008.1"><vh>@rst glossary.rst</vh>
<v t="sa.20080715122316.10"><vh>Application</vh></v>
<v t="sa.20080715122316.11"><vh>PushApplication</vh></v>
<v t="sa.20080715122316.12"><vh>User</vh></v>
<v t="sa.20080715111354.4"><vh>Activity</vh></v>
<v t="sa.20080715111354.6"><vh>Role</vh></v>
<v t="sa.20080714081843.26"><vh>Activity-based Workflow</vh></v>
<v t="sa.20080715111354.3"><vh>Process</vh></v>
<v t="sa.20080715111354.5"><vh>Transitions</vh></v>
<v t="sa.20080715111354.25"><vh>Workflow</vh></v>
<v t="sa.20080715111354.7"><vh>ProcessInstance</vh></v>
<v t="sa.20080715111354.8"><vh>WorkItem</vh></v>
</v>
<v t="sa.20080715012904.1"><vh>@rst credits.rst</vh></v>
<v t="sa.20080715012904.2"><vh>@rst license.rst</vh></v>
<v t="sa.20080714012008.12"><vh>modules</vh>
<v t="sa.20080714012008.13"><vh>gen_modules.py</vh>
<v t="sa.20080714012008.14"><vh>gen_modules declarations</vh></v>
<v t="sa.20080714012008.15"><vh>main</vh></v>
</v>
<v t="sa.20080714012008.41"><vh>@rst index.rst</vh></v>
<v t="sa.20080714012008.16"><vh>@rst goflow.graphics.models.rst</vh></v>
<v t="sa.20080714012008.17"><vh>@rst goflow.graphics.rst</vh></v>
<v t="sa.20080714012008.18"><vh>@rst goflow.graphics.urls_admin.rst</vh></v>
<v t="sa.20080714012008.19"><vh>@rst goflow.graphics.views.rst</vh></v>
<v t="sa.20080714012008.20"><vh>@rst goflow.graphics2.models.rst</vh></v>
<v t="sa.20080714012008.21"><vh>@rst goflow.graphics2.rst</vh></v>
<v t="sa.20080714012008.22"><vh>@rst goflow.graphics2.views.rst</vh></v>
<v t="sa.20080714012008.23"><vh>@rst goflow.instances.api.rst</vh></v>
<v t="sa.20080714012008.24"><vh>@rst goflow.instances.forms.rst</vh></v>
<v t="sa.20080714012008.25"><vh>@rst goflow.instances.models.rst</vh></v>
<v t="sa.20080714012008.26"><vh>@rst goflow.instances.rst</vh></v>
<v t="sa.20080714012008.27"><vh>@rst goflow.instances.urls.rst</vh></v>
<v t="sa.20080714012008.28"><vh>@rst goflow.instances.urls_admin.rst</vh></v>
<v t="sa.20080714012008.29"><vh>@rst goflow.instances.views.rst</vh></v>
<v t="sa.20080714012008.30"><vh>@rst goflow.rst</vh></v>
<v t="sa.20080714012008.31"><vh>@rst goflow.workflow.api.rst</vh></v>
<v t="sa.20080714012008.32"><vh>@rst goflow.workflow.applications.rst</vh></v>
<v t="sa.20080714012008.33"><vh>@rst goflow.workflow.decorators.rst</vh></v>
<v t="sa.20080714012008.34"><vh>@rst goflow.workflow.forms.rst</vh></v>
<v t="sa.20080714012008.35"><vh>@rst goflow.workflow.logger.rst</vh></v>
<v t="sa.20080714012008.36"><vh>@rst goflow.workflow.models.rst</vh></v>
<v t="sa.20080714012008.37"><vh>@rst goflow.workflow.notification.rst</vh></v>
<v t="sa.20080714012008.38"><vh>@rst goflow.workflow.pushapps.rst</vh></v>
<v t="sa.20080714012008.39"><vh>@rst goflow.workflow.rst</vh></v>
<v t="sa.20080714012008.40"><vh>@rst goflow.workflow.views.rst</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sa.20080714011136.1"></t>
<t tx="sa.20080714011136.2">@ @rst-options
default_path=docs/source
write_intermediate_file=True
show_headlines=True
@c

@language rest
</t>
<t tx="sa.20080714012008.1">.. _glossary:

=========
Glossary
=========


..  glossary:: 


</t>
<t tx="sa.20080714012008.2">.. _overview:

============
Overview
============
</t>
<t tx="sa.20080714012008.3">
.. _faq:


============
GoFlow FAQ
============







</t>
<t tx="sa.20080714012008.5">
.. _tutorial:

==================
GoFlow User Guide
==================

GoFlow is a `django component` which adds activity-based workflow features to a django project.

We'll learn here how to use this module, starting with a very simple "Hello world" django project, and then gradually add features as we go along.
</t>
<t tx="sa.20080714012008.6">=====================
GoFlow Documentation
=====================

Contents
==========

.. toctree::
   :maxdepth: 2

   overview.rst
   patterns.rst
   tutorials.rst
   install.rst
   faq.rst
   changes.rst
   history.rst
   license.rst
   credits.rst
   definitions.rst

   modules/index.rst
   glossary.rst
   

Indices and tables
===================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
</t>
<t tx="sa.20080714012008.7">
.. _history:

=======
History
=======







</t>
<t tx="sa.20080714012008.8">
.. _definitions:

==========================
Definitions
==========================









</t>
<t tx="sa.20080714012008.9">.. _install:

==================
Installation
==================

    
Python
-------
      
Depending on your platform you can install python from http://www.python.org and version 2.5.2 is the version that we are using here.
      

Django
-------
   
Try to get the latest subversion trunk version of django from http://www.djangoproject.com
    
    
GoFlow
-------

Latest Release: 
    
    * All releases are available here: http://code.google.com/p/goflow/downloads/list
    
Subversion trunk code::
    
    svn checkout http://goflow.googlecode.com/svn/trunk/ goflow-src
    

  
Optional (but useful) Modules      
-------------------------------

    * Graphviz
    * PIL  
    * Pyyaml
    * Pygraphviz

</t>
<t tx="sa.20080714012008.11">.. _changes:

==========
What's new
==========

.. contents::




</t>
<t tx="sa.20080714012008.12">@ @rst-options
default_path=docs/source/modules
@c</t>
<t tx="sa.20080714012008.13">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    main()

</t>
<t tx="sa.20080714012008.14">import sys, os
from Cheetah.Template import Template

template ='''
.. _${mod.name}:

:mod:`${mod.name}` -- ${mod.synopsis} 
================================================================================

.. module:: ${mod.name} 
   :synopsis: ${mod.synopsis}

'''

template_ ='''
.. _${mod.name}:

:mod:`${mod.name}` -- ${mod.synopsis} 
================================================================================

..  automodule:: ${mod.name} 
    :members:
    :undoc-members:
    :inherited-members:
'''

lst = [
    ("goflow.rst","primary module containing other goflow submodules."),
    ("goflow.graphics.rst","early goflow graphics module"),
    ("goflow.graphics.models.rst","datamodels for graphics processing"),
    ("goflow.graphics.views.rst","goflow graphics views"),
    ("goflow.graphics.urls_admin.rst","goflow graphics custom admin interface"),
    ("goflow.graphics2.rst","latest goflow graphics module"),
    ("goflow.graphics2.models.rst","datamodels for graphics2 processing"),
    ("goflow.graphics2.views.rst","view functions for graphics2 module"),
    ("goflow.instances.rst","goflow runtime"),
    ("goflow.instances.api.rst","goflow runtime api"),
    ("goflow.instances.forms.rst","goflow runtime forms"),
    ("goflow.instances.models.rst","goflow runtime models"),
    ("goflow.instances.views.rst","goflow runtime views"),
    ("goflow.instances.urls.rst","goflow runtime urls"),
    ("goflow.instances.urls_admin.rst","goflow runtime custom admin interface"),
    ("goflow.workflow.rst","goflow core workflow functionality"),
    ("goflow.workflow.api.rst","key functions for workflow management"),
    ("goflow.workflow.applications.rst","key application function for workflow mgmt"),
    ("goflow.workflow.decorators.rst","goflow decorator library"),
    ("goflow.workflow.forms.rst","goflow form utility functions"),
    ("goflow.workflow.logger.rst","logging capability"),
    ("goflow.workflow.models.rst","workflow models"),
    ("goflow.workflow.notification.rst","workflow notification library"),
    ("goflow.workflow.pushapps.rst","example goflow pushapps"),
    ("goflow.workflow.views.rst","views for goflow worklow module"),
]


</t>
<t tx="sa.20080714012008.15">def main():
    results=[]
    for fname, synopsis in lst:
        mod = dict(name=fname[:-4], file=fname, synopsis=synopsis)
        out = file(fname, 'w')
        out.write(str(Template(template, searchList=[dict(mod=mod)])))
        out.close()

    


</t>
<t tx="sa.20080714012008.16">

.. _goflow.graphics.models:

:mod:`goflow.graphics.models` -- datamodels for graphics processing 
================================================================================

.. module:: goflow.graphics.models 
   :synopsis: datamodels for graphics processing

</t>
<t tx="sa.20080714012008.17">

.. _goflow.graphics:

:mod:`goflow.graphics` -- early goflow graphics module 
================================================================================

.. module:: goflow.graphics 
   :synopsis: early goflow graphics module

</t>
<t tx="sa.20080714012008.18">

.. _goflow.graphics.urls_admin:

:mod:`goflow.graphics.urls_admin` -- goflow graphics custom admin interface 
================================================================================

.. module:: goflow.graphics.urls_admin 
   :synopsis: goflow graphics custom admin interface

</t>
<t tx="sa.20080714012008.19">

.. _goflow.graphics.views:

:mod:`goflow.graphics.views` -- goflow graphics views 
================================================================================

.. module:: goflow.graphics.views 
   :synopsis: goflow graphics views

</t>
<t tx="sa.20080714012008.20">

.. _goflow.graphics2.models:

:mod:`goflow.graphics2.models` -- datamodels for graphics2 processing 
================================================================================

.. module:: goflow.graphics2.models 
   :synopsis: datamodels for graphics2 processing

</t>
<t tx="sa.20080714012008.21">

.. _goflow.graphics2:

:mod:`goflow.graphics2` -- latest goflow graphics module 
================================================================================

.. module:: goflow.graphics2 
   :synopsis: latest goflow graphics module

</t>
<t tx="sa.20080714012008.22">

.. _goflow.graphics2.views:

:mod:`goflow.graphics2.views` -- view functions for graphics2 module 
================================================================================

.. module:: goflow.graphics2.views 
   :synopsis: view functions for graphics2 module

</t>
<t tx="sa.20080714012008.23">

.. _goflow.instances.api:

:mod:`goflow.instances.api` -- goflow runtime api 
================================================================================

.. automodule:: goflow.instances.api 
   :synopsis: goflow runtime api
   :members:

</t>
<t tx="sa.20080714012008.24">

.. _goflow.instances.forms:

:mod:`goflow.instances.forms` -- goflow runtime forms 
================================================================================

.. module:: goflow.instances.forms 
   :synopsis: goflow runtime forms

</t>
<t tx="sa.20080714012008.25">

.. _goflow.instances.models:

:mod:`goflow.instances.models` -- goflow runtime models 
================================================================================

.. module:: goflow.instances.models 
   :synopsis: goflow runtime models

</t>
<t tx="sa.20080714012008.26">

.. _goflow.instances:

:mod:`goflow.instances` -- goflow runtime 
================================================================================

.. module:: goflow.instances 
   :synopsis: goflow runtime

</t>
<t tx="sa.20080714012008.27">

.. _goflow.instances.urls:

:mod:`goflow.instances.urls` -- goflow runtime urls 
================================================================================

.. module:: goflow.instances.urls 
   :synopsis: goflow runtime urls

</t>
<t tx="sa.20080714012008.28">

.. _goflow.instances.urls_admin:

:mod:`goflow.instances.urls_admin` -- goflow runtime custom admin interface 
================================================================================

.. module:: goflow.instances.urls_admin 
   :synopsis: goflow runtime custom admin interface

</t>
<t tx="sa.20080714012008.29">

.. _goflow.instances.views:

:mod:`goflow.instances.views` -- goflow runtime views 
================================================================================

.. module:: goflow.instances.views 
   :synopsis: goflow runtime views

</t>
<t tx="sa.20080714012008.30">

.. _goflow:

:mod:`goflow` -- primary module containing other goflow submodules. 
================================================================================

.. module:: goflow 
   :synopsis: primary module containing other goflow submodules.

</t>
<t tx="sa.20080714012008.31">

.. _goflow.workflow.api:

:mod:`goflow.workflow.api` -- key functions for workflow management 
================================================================================

.. module:: goflow.workflow.api 
   :synopsis: key functions for workflow management


</t>
<t tx="sa.20080714012008.32">

.. _goflow.workflow.applications:

:mod:`goflow.workflow.applications` -- key application function for workflow mgmt 
==================================================================================

.. module:: goflow.workflow.applications 
   :synopsis: key application function for workflow mgmt


.. function:: format_exception(etype, value, tb[, limit=None])

   Format the exception with a traceback.

   :param object: exception type
   :param value: exception value
   :param tb: traceback object
   :param limit: maximum number of stack frames to show
   :type limit: integer or None
   :rtype: list of strings</t>
<t tx="sa.20080714012008.33">

.. _goflow.workflow.decorators:

:mod:`goflow.workflow.decorators` -- goflow decorator library 
================================================================================

.. module:: goflow.workflow.decorators 
   :synopsis: goflow decorator library

</t>
<t tx="sa.20080714012008.34">

.. _goflow.workflow.forms:

:mod:`goflow.workflow.forms` -- goflow form utility functions 
================================================================================

.. module:: goflow.workflow.forms 
   :synopsis: goflow form utility functions

</t>
<t tx="sa.20080714012008.35">

.. _goflow.workflow.logger:

:mod:`goflow.workflow.logger` -- logging capability 
================================================================================

.. module:: goflow.workflow.logger 
   :synopsis: logging capability

</t>
<t tx="sa.20080714012008.36">

.. _goflow.workflow.models:

:mod:`goflow.workflow.models` -- workflow models 
================================================================================

.. module:: goflow.workflow.models 
   :synopsis: workflow models

</t>
<t tx="sa.20080714012008.37">

.. _goflow.workflow.notification:

:mod:`goflow.workflow.notification` -- workflow notification library 
================================================================================

.. module:: goflow.workflow.notification 
   :synopsis: workflow notification library

</t>
<t tx="sa.20080714012008.38">

.. _goflow.workflow.pushapps:

:mod:`goflow.workflow.pushapps` -- example goflow pushapps 
================================================================================

.. module:: goflow.workflow.pushapps 
   :synopsis: example goflow pushapps

</t>
<t tx="sa.20080714012008.39">

.. _goflow.workflow:

:mod:`goflow.workflow` -- goflow core workflow functionality 
================================================================================

.. module:: goflow.workflow 
   :synopsis: goflow core workflow functionality

</t>
<t tx="sa.20080714012008.40">

.. _goflow.workflow.views:

:mod:`goflow.workflow.views` -- views for goflow worklow module 
================================================================================

.. module:: goflow.workflow.views 
   :synopsis: views for goflow worklow module

</t>
<t tx="sa.20080714012008.41">
=====================
GoFlow Modules
=====================

.. contents::

goflow
==========

.. toctree::
   :maxdepth: 2

   goflow.rst

goflow.graphics
-----------------

.. toctree::
   :maxdepth: 2

   goflow.graphics.rst
   goflow.graphics.models.rst
   goflow.graphics.views.rst
   goflow.graphics.urls_admin.rst

goflow.graphics2
-----------------

.. toctree::
   :maxdepth: 2

   goflow.graphics2.rst
   goflow.graphics2.models.rst
   goflow.graphics2.views.rst

goflow.instances
-----------------

.. toctree::
   :maxdepth: 2
      
   goflow.instances.rst
   goflow.instances.api.rst
   goflow.instances.forms.rst
   goflow.instances.models.rst
   goflow.instances.views.rst
   goflow.instances.urls.rst
   goflow.instances.urls_admin.rst

goflow.workflow
-----------------

.. toctree::
   :maxdepth: 2

   goflow.workflow.rst
   goflow.workflow.api.rst
   goflow.workflow.applications.rst
   goflow.workflow.decorators.rst
   goflow.workflow.forms.rst
   goflow.workflow.logger.rst
   goflow.workflow.models.rst
   goflow.workflow.notification.rst
   goflow.workflow.pushapps.rst
   goflow.workflow.views.rst


Indices and tables
===================
* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
</t>
<t tx="sa.20080714012008.42">.. _patterns:

====================
Workflow Patterns
====================

    * Sequence:
        An ActivityInstance is enabled after another ActivityInstance
        in the same ProcessInstance has completed.

    * Parallel Split (AND-Split):
        A point in the ProcessInstance where it splits into several, 
        parallel running ActivityInstances.

    * Exclusive Choice (XOR-Split):
        A point in the Process where ONE of n Transitions evaluates true 
        and creates ONE new ActivityInstance (first-come-first-serve).

    * Synchronisation (AND-Join):
        A point in the ProcessInstance? that needs to wait for all incoming
        Transitions from previous ActivityInstances and then processes
        further.

    * Simple Join (XOR-Join):
        A point in the ProcessInstance that waits for one incoming 
        Transition from an ActivityInstance and then processes further.

    * Loop:
        Repeat a certain sequence of Activities until a condition 
        evaluates true
</t>
<t tx="sa.20080714012008.44">

..  image:: images/and-join.png
    :align: center

</t>
<t tx="sa.20080714012008.45">

..  image:: images/and-split.png
    :align: center

</t>
<t tx="sa.20080714081843.1">This document presents an introduction to "GoFlow", a workflow engine for django. 

The manual has been generated from reStructuredText source markup with
Sphinx, which should make it much easier to keep it up-to-date in the
future.

</t>
<t tx="sa.20080714081843.2">GoFlow is an activity based workflow management system that is designed as django component.

Being activity based means that the processes, the workflows, are made of activities to be completed in order to get something done. This differs from entity based workflows where the focus is set on a given document and the states it has to go through in order to be completed.

For example, the process describing a research in your campus library can be handled as an activity based process: you have to get a signed authorization by your teacher, go find your books of interest using either the computer catalogs or the librarian's help, and then check-out the books you need (signing the appropriate stuff). This is a list of activities to be carried out in order to get some books out of the library.
There is no main document in this process.

Another example of an activity based process might be represented by the fund request submission process. A teacher of the university has to submit a request for buying a new computer. The process starts by filling in a form where the teacher specifies what he intends to buy and how much this costs. The form will be handled by the administration office and, if the total cost goes beyond a given threshold, it requires the personal authorization by the administration chief. Budget is then checked to see if the teacher has appropriate funds left for the acquisition. In the end an e-mail is sent to the teacher telling him the result of the submission; the request is filed in the request archive and the funding database is updated subtracting the requested cost from the available money left. This process has a main document (the request) but it has a lot of side actions to be carried out as well: signed authorization, archive insertion, database update, e-mail sending. The best way to describe this is through an activity based workflow, where the process is made of activities to be carried out.

On the other hand simpler processes do not require the complex structure of an actvity based workflow management system, and a simple entity-based workflow would suffice. For example the publication of documents on a web site can be simply modelled by the given document going through the states of new, submitted, and then approved or rejected. In such workflows the document is the main issue, and its available actions are defined by its current state.</t>
<t tx="sa.20080714081843.3">The main purpose of a workflow management system is to address the problem of "who must do what, when and how". 

In an activity based workflow management system (such as GoFlow) this problem finds a solution.

To this end, GoFlow provides a number of key functional elements:

    * The **Process** defining the sequence of activities to be carried out says what should be done and when by the definition of activities and transitions. 

    * An **Activity** (the *what* part of the workflow) represents something to be done: giving authorization, updating a database, sending an e-mail, loading a truck, filling a form, printing a document and so on. 
    
    * A **Transition** defines the appropriate sequence of activities for a process (the *when* part of the issue).

    * Each activity will have an associated **Application** designed to carry out the job: the *how* part. 
    
    * The *who* part is generally the **User** assigned to carry out the activity, through its application. Usually activity applications will be used by someone, a person, but in many cases the entity assigned to an activity might be an automatic system. Afterall, why should you have a person waste time updating a database if it can be done in software directly?

</t>
<t tx="sa.20080714081843.4"></t>
<t tx="sa.20080714081843.5">One reason to use a workflow management system is to improve the efficiency and performance of the processes you usually handle. A lot of activities you usually do can actually be carried out by an automatic system. Database update, e-mail sending, research, document archiving and so on are activities that a computer can carry out with no need for human intervention. This means that the activity job will be completed much faster and the human resources can be used in some more valuable way (and they will be grateful for that).</t>
<t tx="sa.20080714081843.6">Another reason to use a workflow management system is to always have the answer to the question "who must do what, when and how". Formalizing your process means wasting no time in deciding what to do, having each person performing the right job and being sure that your process can be completed appropriately.</t>
<t tx="sa.20080714081843.7">The goal of a process definition is to give answer the question "who must do what, when and how".

Activities and transitions describe the process you want to model (the what and when part). You can see them as the "bubbles and arrows" description of what has to be done and when. 

Applications describe the how part and are associated with activities. Users and roles describe the who part.</t>
<t tx="sa.20080714081843.8">Each activity can be of three different kinds: application, sub-process or routing. Usually each activity of the process definition describes something that has do be done, some kind of work. This work can be either carried out by an application or by a sub process definition that better refines the job to be done.

Sometimes an activity will be assigned the simple job of handling the routing of work in the process. In this case the activity is just a dummy activity that simply chooses what to do next.

Each activity has one incoming guard for collecting incoming transitions that lead to it. The activity incoming guard can be either set to and or xor for two different behaviour:

    * and: means that all the activities that lead to this activity have to be
      completed in order to enable this activity to work.

    * xor: means that just one of the activities that lead to this activity has to be 
      completed in order to enable this activity to work.

Each activity also has one outgoing guard for collecting outgoing transitions getting out of it. Again, the activity outgoing guard can be either set to and or xor for two different behaviours:

    * and: means that this activity will trigger the work of all the activities it   
      connects to; doing this the flow in the process will be split in parallel 
      (concurrent) flows.

    * xor: means that this activity will trigger the work of just one of the 
      activities it connects to, depending on condition evaluation (see transitions 
      below).
    
Work performed by an activity will be triggered in different ways as determined by the start mode setting of the activity itself. It can be set to either:

    * automatic: the activity will run its application as soon as an instance 
      workitem reaches it. There will be no worklist for users: it will be openflow 
      itself taking care of starting the activity application on the workitem.

    * manual: openflow will wait for user intervention to start the activity 
      application: usually this is done through the call to the "callApplication" API 
      of workflow. This worklist the user is using (like the default worklist in 
      openflow does).

When an application completes its job the activity finish mode will be evaluated. It can be set to either:

    * automatic: as soon as a "completeWorkitem" api is called (supposedly by the activity
      application upon ending its work) the instance will be automatically 
      finish mode this will not be done, and user (again, the activity application upon 
      have to call the "forwardWorkitem" api. This enables the user to choose a given path  
      (transition) for the instance to follow. So mainly this mode is reserved for manually 
      steering the instance in alternative paths of the process. (Remember that you can 
      automatically steer the instance giving condition to transitions: see below).
</t>
<t tx="sa.20080714081843.9">Transitions connect activities together. A transition connecting activity A with activity B states that as soon as A is finished B has to be started.

Transitions can be guarded by conditions. A transition condition will be evaluated if the "from" activity has choose one and only one path to be followed (ie: the activity has an xor outgoing guard).</t>
<t tx="sa.20080714081843.10">An application is assigned to each activity in order to carry out the job the activity has to do. 

Applications can be anything triggered by an url call: python scripts, dtml forms, sql queries, Zope applications or even external applications like word or other custom and dedicated applications.

What the application is required to do is to invoke the appropriate api for interacting with GoFlow. For example the application will need to invoke the Openflow completeWorkitem to signal Openflow that its job is finished and a new activity can be started.</t>
<t tx="sa.20080714081843.11">Users are assigned to applications through roles.

The available roles for openflow are the django-defined roles. To add a role just add a group role to the folder where you build your application.

One user can be listed in one or more roles. Roles can list one or more activities. Each user will be able to work on all activities listed in roles he is listed in.

Actually each role will keep three different lists:

    * users list: list of users assigned to the role
    
    * enabled activities: list of process activities that users listed in this role can 
      work on
    
    * assignable activities: list of process activities that users listed in this 
      role can assign to other users</t>
<t tx="sa.20080714081843.12">A process definition gives the instructions for completing some work. A process instance, in turn, is an actual execution of a process definition.

For example, if the process definition describes what should be done for submitting a fund request, a process instance of that process definition is an actual submission for funding.</t>
<t tx="sa.20080714081843.13">We call workitem the execution of a single activity of the process definition. Workitems are created every time an activity is triggered. Workitems are never destroyed, even when an activity completes its job, the workitem created to represent the execution of that activity is just set to a complete state. A process instance is a collection of workitems: one per activity executed (or in execution).

One of the most important jobs of a workitem is to keep track of events during the execution of its activity. Since the process instance keeps track of all its workitems, and each workitem keeps track of all the events that happen during the execution of the activity, the complete history of everyting that has happened is recorded in each process instance.

This is very useful for two reasons:
    
    * you can have access to an event log of every single instance begun in your process
    
    * you can learn from analysis of these reports how to better design your process,
      considering load balancing, completion times, and so on.</t>
<t tx="sa.20080714081843.14">To each user is associated a worklist: a list of workitems pending on activities the user is supposed to perform. The worklist is not set to a given size: it grows when activities require additional work to be done, and it shrinks as the work on activities is completed.

Users are presented their worklists to let them know what is to be done. In Openflow three policies exist for work assignment: pull, manual push and automatic push.

* pull policy means that users will choose what to do, as if the work to be done was gathered in a common pool where users go fetch what they want to take care of

* manual push policy means the user is assigned work by another user

* automatic push policy means the user is automatically assigned work by the engine itself

You can see this as having the process instance workitems assigned to users: pulling will be self assignment and pushing will be assignment by somebody else (or by the engine itself).

Whichever policy is used for assigning work, once a user is assigned some work he will be the only one enabled to carry it out: Other users will not see the assigned work in their worklist.
</t>
<t tx="sa.20080714081843.15">In existing workflow management systems flexibility is a major issue. When you design a process definition there is variable (and usually low) chance the process you defined is actually the most appropriate model you could get of the process.

It is very important to have a way to handle cases that go outside of the set boundary, the "exceptions". At the same time it is also important to have tools that let you change the process definition even while it is running: it can be dramatic having to stop your processes to change their definitions.

</t>
<t tx="sa.20080714081843.16">Exception handling is necessary for unforeseen situations when users have to handle something that the process was not designed to handle.

Instead of a normal handling of a workitem the user can make it "fall out" of the normal process flow. The fallen (exceptional) token will then be available to any user assigned to handle exceptions. As soon as the workitem is fixed, it can be inserted into any activity of the process to resume the process flow. In this way the user can change the workitem data anyway he wants, to adjust to the exceptional situation.

</t>
<t tx="sa.20080714081843.17">A process definition can be changed while in execution (while process instances run the flow). New activities can be added, old ones deleted, transition created or changed and so on. Any invalidating situation that might occur will be handled, causing the appropriate workitem to fall out (go into exceptional state).

As soon as the process is changed all the current process instances will read the new process definition as the definition to be used.

Dynamic redesign and exception handling are related to each other. Exception handling allows for dealing with unforeseen events: it should suggest changes in the process definition to handle that situation in the future. On the other hand dynamic redesign will probably put some (or all) process instances into an invalid state: exception handling should be used to recover from these situations.</t>
<t tx="sa.20080714081843.18"></t>
<t tx="sa.20080714081843.19"></t>
<t tx="sa.20080714081843.20"></t>
<t tx="sa.20080714081843.21">To understand what is ``activity based workflow`` take a look at `OpenFlow`_ 

.. _OpenFlow: http://www.openflow.it/Documentation/documentation/OpenFlowIntroduction
</t>
<t tx="sa.20080714081843.22">When an Activity is activated (automatically or manually by calling activate API method) it is assigned to the User that is returned by PushApplication. If there is no PushApplication then Activity is assigned to selected Roles. If you choose both, then only PushApplication is used.</t>
<t tx="sa.20080714081843.23">AutoStart and AutoFinish are start mode and finish mode as described here: http://www.openflow.it/Documentation/documentation/OpenFlowIntroduction For example if AutoStart is not checked, then to start Activity it is necessary to call activate API function on it. If AutoStart is checked, then it is automatically activated as soon as previous activities are finished (depending on guard condition: xor, and) </t>
<t tx="sa.20080714081843.24">The good practise is to reuse Applications, not Activities: Applications should be reused because they take time to build; Activities are just containers for applications, with some parameters to fit the process needs.

You can customize application with parameters:

    * at global level, in urls.py files
    * at process level, in activities (application parameters field)

</t>
<t tx="sa.20080714081843.25">transitions have a condition attribute: it is a python expression that returns a boolean. the variables that can be used in the boolean expression are instance and workitem. examples:

    * OK: the user has pushed the OK button
    * instance.condition == "OK": the user has pushed the OK button
    * workitem.time_out(delay=5, unit='days'): the task is waiting for 5 days or more (NYI but soon)</t>
<t tx="sa.20080714081843.26">
An activity-based workflow is a workflow that is centered around a set of activities that someone (or something) has to do.

A given process instance (an instance of a process definition) may have several active workitems, which are the "pending" work a given actor has to do. Once a workitem is completed, the process definition specifies what are the next activities, and thus what new workitems must be created.

The main concepts in the definition of a process for an activity-based workflow are:

    * activities
        * applications that describe work
        * sub-process that recursively describe another process
    * transitions, with guards, deciding what's next</t>
<t tx="sa.20080714081843.28">Prerequisite
=================
Create a directory, and copy the directory ``goflow`` to this directory (you can also place it in any directory in your PYTHONPATH).

.. note::
   While the Django documentation advocates the use of absolute paths, the use of relative paths
   in what follows is voluntary. This is done in order to simplify expressions and to be platform 
   independent (and it works, at least under Windows and OS X)</t>
<t tx="sa.20080714081843.29">Project "Hello World"
======================
We will discover the workflow engine with a very simple application based on a process workflow with a single activity (a single activity, with no transitions: the simplest possible workflow). The purpose of this activity is to receive a message (for example, "Hello world").

    * Start by creating an empty django project (or use an existing project)::

        Django admin-startproj myproj

    * Add the following applications in the file ``settings.py``::

        INSTALLED_APPS = (
         ...
         'django.contrib.admin'
         'goflow.workflow'
         'goflow.instances'
        )

The `workflow` application contains the "static" model data (modeling
process), and the ``instances`` application contains the dynamic part or runtime.

    * Set up the database part of the settings file, for example like this::

        DATABASE_ENGINE = 'sqlite3'
        DATABASE_NAME = 'data.sqlite'

    * Add the following two lines in the ``urls.py``  file::

        urlpatterns = patterns (``,
         ...

         # Uncomment this for admin:
         (r '^ admin /', include ( 'django.contrib.admin.urls')),
         (r '^ workflow /', include ( 'goflow.urls')),
        )


    * Now create the database server and start it as follows::

        python manage.py syncdb - pythonpath =..
        python manage.py runserver - pythonpath =..


We can now open the console admin [http://localhost:8000/admin], and discover the data models introduced by GoFlow:

..  image:: images/admin1.png
    :align: center

We can also discover the GoFlow Dashboard, which provide easy access to the status of workflows using a "back-office" perspective, [http://localhost:8000/workflow]

..  image:: images/admin2.png
    :align: center

We will now create a process workflow.

Return to the admin console, add an entity Process as shown with the screen below:

..  image:: images/admin4.png
    :align: center

Use "Hello world" for the title, and optionally provide a description of the new process

    * Register using the ``Save button and continue editing``: you can now see that an 
      activity ``End`` was added automatically.

    * Create an initial activity by clicking on the icon "+" in the field ``Initial activity``: 
      enter a title, set the process dropdown to the current process "Hello world", leaving the 
      default values for other fields.

    * Save

We have created our first process workflow:

..  image:: images/admin4.png
    :align: center

You may observe that we have not yet specified an application (a url with underlying functionality e.g. views/templates/classes/functions/modules etc..) for our business, and we will shortly see that this is not necessary to begin to "play" with our application.

Indeed, when an activity is not associated with an application, a special testing application is still invoked to simulate this activity: providing a panel to the user, displaying the name, description of the activity, and also a history of the workflow, with an ``OK`` button allowing you to complete the activity.

Before we start running our process workflow, we must first create a ``Group`` with a single permission to allow users to instantiate it:

    * Add a group named ``Hello world``, give it the permission ``can_instantiate`` on the  
      content type ``workflow.process``, and save. (note: the name of the group and the name of 
      the process must be the same)
      
    * Add this group to the current user: this will allow the user to instantiate the process 
      ``Hello world``.

We are now ready to execute/test the workflow: go to the dashboard [http://localhost:8000/workflow]. You will find the process and its definition, and other information on roles and permissions.

    * Click on the link ``start a simulation instance`` under the process ``Hello world``
</t>
<t tx="sa.20080714081843.30"></t>
<t tx="sa.20080714081843.31"></t>
<t tx="sa.20080714081843.32">we will implement some forms methods.</t>
<t tx="sa.20080714081843.33">GoFlow Advanced
============================</t>
<t tx="sa.20080714081843.34">    * use goflow svn version as version 0.5 will not work with these tutorials. You can also 
      download the [http://goflow.googlecode.com/files/goflow-0.51.zip v 0.51].
  
    * It is helpful to have a "played" with the demo goflow leave (available online). 
      [http://goflow.alwaysdata.net/leave/]

(tutorial draft; screenshots will be added later)</t>
<t tx="sa.20080714081843.35">We will simulate here coding an existing application of the demo ``Leave``: ``hrform``.

    * Launch the local server of the demo ``leave`` in the ``leavedemo`` folder (cf. INSTALL.TXT 
      file)
  
    * Go to the admin console: [http://localhost:8000/leave/admin/]
  
    * Create a !LeaveRequest object: [http://localhost:8000/leave/admin/leave/leaverequest/add/]
        * This object will be used as a model when performing unit tests; hence provide the 
          beginning and end dates, type of absence, the requester (admin), and the reason (e.g 
          "test")
          
    * On the applications panel: [http://localhost:8000/leave/admin/workflow/application/]
    
        * Click on the ``create unit test`` link in the ``hrform`` application row: this will 
          create a process with a single activity that will run the application ``hrform``.
          
        * Click on ``return``
        
        * Click  on the ``start test forums`` link in the ``hrform`` application row; then choose 
          the content type ``leave request`` and click ``OK``: this will initiate as many 
          workflow instances as !LeaveRequest instances that we manually manually before (here, 
          only one).
          
    * Go to the task list of the admin user: [http://localhost:8000/leave/mywork/]
    
    * There must be a task for an activity called ``test_activity`` in the workflow process 
      ``test_hrform``
      
    * Clicking on the link ``activate`` should lead you to the panel corresponding to the 
      implementation of the ``hrform`` application.

Here we have simulated/tested an application in a process workflow; it seems very little, but it is important to have in mind that in the development of complex workflows, and in order to efficiently work in teams, each activity should be coded and tested independently of each other. 

That is why GoFlow is equipped with tools, available in the console admin customized for this purpose, to help the developer generate a test environment for each application.
</t>
<t tx="sa.20080714081843.36">We are going to replace an application that currently requires human intervention by an automatic activity. We will work on the previous application ``hrform`` and replace it with the application ``hr_auto`` which will perform the same function but automatically (in fact, this is a simplified version, because calculating the number of days worked between two dates is not trivial).
 
TODO</t>
<t tx="sa.20080714081843.37">The current GoFlow system grew out of the OpenFlow project.
</t>
<t tx="sa.20080714081843.38"></t>
<t tx="sa.20080714081843.39"></t>
<t tx="sa.20080714081843.40"></t>
<t tx="sa.20080714225902.5"></t>
<t tx="sa.20080714225902.6">
	* Improved documentation based on leo-editor, Sphinx and epydoc. 
</t>
<t tx="sa.20080714225902.7">	* a bug was found here.

</t>
<t tx="sa.20080714225902.8">	* api was cleaned up to make it more consistent.

</t>
<t tx="sa.20080714235246.1"></t>
<t tx="sa.20080715012904.1">.. _credits:

We are grateful to x, y and z for support of this project.

    * GoFlow is based on OpenFlow
    
    * etc..
</t>
<t tx="sa.20080715012904.2">.. _license:

insert license here.</t>
<t tx="sa.20080715111354.1">GoFlow is an "activity based" workflow. Workflow processes are implemented as a set of activities that must be completed to achieve some result. In GoFlow, the logic of activities lies in python view scripts. The presentation consists of a django (or any other kind of) template. GoFlow provides three main modules: 

    * Workflow API, 
    * Workflow Runtime
    * Workflow Admin.

</t>
<t tx="sa.20080715111354.2"></t>
<t tx="sa.20080715111354.3">A process is defined as a set of activities that must be done to achieve some goal. Business interactions are mapped to GoFlow processes to automate them. Process activities are connected using transitions defining what has to be done after each activity is completed.

</t>
<t tx="sa.20080715111354.4">An activity is a task that must be completed as a part of a process. In GoFlow activities are mapped to python scripts. This way an activity can do anything that can be done from a python script.</t>
<t tx="sa.20080715111354.5">Transitions defines which activity or activities come before an activity is executed and after it is completed.
</t>
<t tx="sa.20080715111354.6">Roles define who can perform an associated activity. Roles are defined at a per-process level.

</t>
<t tx="sa.20080715111354.7">An instance is an occurrence of a process being executed. An instance is created when a process is started. The instance passes through the process activities until the process is terminated.

</t>
<t tx="sa.20080715111354.8">A workitem is added to the instance when an activity is completed. Workitems thus represent completed activities.

</t>
<t tx="sa.20080715111354.9">GoFlow defines seven basic activity types that can be used to design a process. They are:

    * Start
    * End
    * Activity
    * Switch
    * Split
    * Join
    * Standalone 
</t>
<t tx="sa.20080715111354.10">Start activities
--------------------
	Start activities are represented using a circle. Every process must have at least one start activity. Start is the only activity type that can be executed without the presence of an instance in the activity because instances are created when a start activity is executed. Processes with many start activities are awkward but possible in GoFlow. No transitions can lead to a start activity and only one outgoing transition is allowed per start activity.
    </t>
<t tx="sa.20080715111354.11">The end activity represents the end of a process. When an instance reaches the end activity the process is considered completed. Process must have exactly one end activity. This doesnt mean that processes cant end in different ways, since the end activity represents only that the process ends. How the process ends depends on the activities visited before the end activity. The end activity is represented in GoFlow using a double circle. The end activity can have many inbound transitions. Outbound transitions are not allowed.


Rules: Valid processes must have at least one begin activity and exactly one end activity. There must be at least one path leading from a start activity to the end activity.
</t>
<t tx="sa.20080715111354.12">Normal activities dont have a special meaning so they are used to represent tasks that should be done as a part of a process. A rectangle is used to represent these activities. Normal activities can receive many inbound transitions but can only have one outbound transition.</t>
<t tx="sa.20080715111354.13">A switch activity represents a point of decision in a process. Instances reaching a switch activity are evaluated and depending on some conditions the instance can be routed to different activities. Switch activities can have many inbound transitions and many outbound transitions. Switch activities are represented using a diamond.
</t>
<t tx="sa.20080715111354.14">Sometimes two or more activities in a process can be done independently in parallel. A split activity is used to split an instance and route it to many activities. This way an instance can be in many activities at the same time. Split activities represent subflows in a workflow. A split activity can receive many inbound transitions and can have many outbound transitions. Split activities are represented by a triangle.</t>
<t tx="sa.20080715111354.15">A join activity is used to regroup instances splitted from a split activity. When an instance reaches a join activity the engine verifies that the instance is present also in some other activity. If so, the instance must wait in the join activity until all activities leading to the join activity are completed. Once all activities reach the join activity the instance can be directed to the next activity. Join activities can have many inbound transitions (more than one is expected) and can only have one outbound activity. Join activities are represented using an inverted triangle.</t>
<t tx="sa.20080715111354.16">	Standalone activities are represented by hexagons. A standalone activity is not part of the normal flow of the process so they are not related to instances. A standalone activity can be executed any time by an user with the required permissions. These activities are ideal for data management related to the process, listings, adding items, removing items, etc. Many processes can be designed as a set of standalone activities if there's no order relationship between the different activities in the process. Other processes consist of a main process flow and a set of auxiliary standalone activities. Standalone activities cant have inbound nor outbound transitions.</t>
<t tx="sa.20080715111354.17"></t>
<t tx="sa.20080715111354.18">When an activitiy is completed the engine may or may not automatically route the instance to the next activity in the process. Activities with the "AutoRouting" setting activated automatically route the instance to the next process activity when the activity is completed. If the activity is not "AutoRouting" the user must "send" the activity after completion to let the instance continue. This can be used in activities where the user can edit information and review it many times before deciding that the activity is completed.</t>
<t tx="sa.20080715111354.19">In GoFlow activities can be automatic or interactive. Interactive activities are activities that require some kind of interaction from the user. These activities usually present a form asking the user to fill some data. After the information is submitted the activity is completed. Automatic activities in contrast are executed automatically by the GoFlow engine without any user interaction. Frequently automatic activities are hidden from the user view of a process.

    * Auto-routed activities have red arrows going out of them.
    * Non-auto-routed activities have black arrows going out of them.
    * Interactive activities have blue borders.
    * Automatic activities have black borders. </t>
<t tx="sa.20080715111354.20">	The picture on the left shows the graph of a process. This process defines requests to a shared CD collection. The start activity (interactive) is where the user picks a CD. Then the manager must verify that the CD is available in the "Approve loan" activity. If the CD is available, the manager sends the CD to the user, and the request is accepted. If not, the request is rejected. The standalone activity "Browse CDs" can be used by the user or the manager to browse the CD collection.</t>
<t tx="sa.20080715111354.21">GoFlow defines three modules:

    * The Process Manager
    * The User Interafce
    * The Process Monitor 
</t>
<t tx="sa.20080715111354.22">The process manager is the module used to create and modify processes. This module is normally used by an administrator and process designers to create processes. The process manager covers the following functionality:

    * Create process and process versions
    * Create, rename, edit and delete activities
    * View a graph of the process activities
    * Check if a process is valid
    * Activate/de-activate a process
    * Edit the source code of activities (python scripts) and templates (Smarty templates)
    * Define roles and define what roles are allowed to execute what activities
    * Map users to roles
    * Export processes to XML files (backup)
    * Load processes from XML files (restore) 

</t>
<t tx="sa.20080715111354.23">The user interface is used by the users to browse processes where they can start new instances, or run activities to which their role has permissions and belong to a particular instance. Users can execute activities, and see the results and some statistics about work asssigned to them.

</t>
<t tx="sa.20080715111354.24">The process monitor is used to monitor and control the execution of processes. The following list shows some features of the process monitor API.

    * List processes, process activities and number of instances per activity
    * List active instances and exceptions
    * Browse instances and modify instance properties
    * Send instances to some activity
    * Assign or reassign an instance to some user
    * Abort instances
    * View statistics about completed processes, execution time, and time spent per activity 

</t>
<t tx="sa.20080715111354.25">
A workflow is a model to represent real work for further assessment, e.g., for describing a reliably repeatable sequence of operations. More abstractly, a workflow is a pattern of activity enabled by a systematic organization of resources, defined roles and mass, energy and information flows, into a work process that can be documented and learned.

The term workflow is used in computer programming to capture and develop human to machine interaction. Workflow software aims to provide end users with an easier way to orchestrate or describe complex processing of data in a visual form, much like flow charts but without the need to understand computers or programming.

Workflow is a term used to describe the tasks, procedural steps, organizations or people involved, required input and output information, and tools needed for each step in a business process. 

A workflow approach to analyzing and managing a business process can be combined with an object-oriented programming approach, which tends to focus on documents and data. In general, workflow management focuses on processes rather than documents. 

A number of companies make workflow automation products that allow a company to create a workflow model and components such as online forms and then to use this product as a way to manage and enforce the consistent handling of work. For example, an insurance company could use a workflow automation application to ensure that a claim was handled consistently from initial call to final settlement. The workflow application would ensure that each person handling the claim used the correct online form and successfully completed their step before allowing the process to proceed to the next person and procedural step.

A workflow engine is the component in a workflow automation program that knows all the procedures, steps in a procedure, and rules for each step. The workflow engine determines whether the process is ready to move to the next step. 

Proponents of the workflow approach believe that task analysis and workflow modeling in themselves are likely to improve business operations.



related concepts: 

    * Petri-Nets: http://en.wikipedia.org/wiki/Petri_net
    </t>
<t tx="sa.20080715122316.2"></t>
<t tx="sa.20080715122316.3"></t>
<t tx="sa.20080715122316.4"></t>
<t tx="sa.20080715122316.5"></t>
<t tx="sa.20080715122316.6"></t>
<t tx="sa.20080715122316.7"></t>
<t tx="sa.20080715122316.8"></t>
<t tx="sa.20080715122316.9"></t>
<t tx="sa.20080715122316.10"></t>
<t tx="sa.20080715122316.11"></t>
<t tx="sa.20080715122316.12"></t>
<t tx="sa.20080716081317.2"></t>
<t tx="sa.20080716081317.3"></t>
<t tx="sa.20080716081317.4"></t>
<t tx="sa.20080716081317.5"></t>
<t tx="sa.20080717192016.4"></t>
<t tx="sa.20080717192016.5">The convergence of two or more branches into a single subsequent branch such that the thread of control is passed to the subsequent branch when all input branches have been enabled.</t>
<t tx="sa.20080717192016.6">synchronization, rendezvous, synchronizer.</t>
<t tx="sa.20080717192016.7">The dispatch-goods task runs immediately after both the check-invoice and produce-invoice tasks are completed.

Cash-drawer reconciliation can only occur when the store has been closed and the credit card summary has been printed.
</t>
<t tx="sa.20080717192016.8">The AND-join patterns provides a means of reconverging the execution threads of two or more parallel branches. In general, these branches are created using the Parallel Split (AND-split) construct earlier in the process model. The thread of control is passed to the task immediately following the synchronizer once all of the incoming branches have completed.
</t>
<t tx="sa.20080717192016.9">The divergence of a branch into two or more parallel branches each of which execute concurrently.</t>
<t tx="sa.20080717192016.10">AND-split, parallel routing, parallel split, fork.</t>
<t tx="sa.20080717192016.11">After completion of the capture enrolment task, run the create student profile and issue enrolment confirmation tasks simultaneously.

When an intrusion alarm is received, trigger the despatch patrol task and the inform police task immediately.

Once the customer has paid for the goods, pack them and issue a receipt.

</t>
<t tx="sa.20080717192016.12">The AND-Split pattern allows a single thread of execution to be split into two or more branches which can execute tasks concurrently. These branches may or may not be re-synchronized at some future time.
</t>
<t tx="sa.20080717192016.13"></t>
<t tx="sa.20080717192016.14">A task in a process in enabled after the completion of a preceding task in the same process.</t>
<t tx="sa.20080717192016.15">Sequential routing, serial routing.</t>
<t tx="sa.20080717192016.16">The verify-account task executes after the credit card details have been captured.

The codacil-signature task follows the contract-signature task.

A receipt is printed after the train ticket is issued.</t>
<t tx="sa.20080717192016.17">The Sequence pattern serves as the fundamental building block for processes. It is used to construct a series of consecutive tasks which execute in turn one after the other. Two tasks form part of a Sequence if there is a control-flow edge from one of them to the next which has no guards or conditions associated with it.</t>
<t tx="sa.20080717192016.18">

..  image:: images/xor-join.png
    :align: center

</t>
<t tx="sa.20080717192016.19">The convergence of two or more branches into a single subsequent branch such that each enablement of an incoming branch results in the thread of control being passed to the subsequent branch.</t>
<t tx="sa.20080717192016.20">Simple Merge, XOR-join, exclusive OR-join, asynchronous join, merge.</t>
<t tx="sa.20080717192016.21">At the conclusion of either the bobcat-excavation or the D9-excavation tasks, an estimate of the amount of earth moved is made for billing purposes.

After the case-payment or provide-credit tasks, initiate the product-receipt task.
</t>
<t tx="sa.20080717192016.22">The Simple Merge pattern provides a means of merging two or more distinct branches without synchronizing them. As such, this presents the opportunity to simplify a process model by removing the need to explicitly replicate a sequence of tasks that is common to two or more branches. Instead, these branches can be joined with a simple merge construct and the common set of tasks need only to be depicted once in the process model.</t>
<t tx="sa.20080717192016.23">

..  image:: images/xor-split.png
    :align: center

</t>
<t tx="sa.20080717192016.24">The divergence of a branch into two or more branches such that when the incoming branch is enabled, the thread of control is immediately passed to precisely one of the outgoing branches based on a mechanism that can select one of the outgoing branches.</t>
<t tx="sa.20080717192016.25">Exclusive choice, XOR-split, exclusive OR-split, conditional routing, switch, decision, case statement.</t>
<t tx="sa.20080717192016.26">Depending on the volume of earth to be moved, either the dispatch-backhoe, dispatch-bobcat or dispatch-D9-excavator task is initiated to complete the job.

After the review election task is completed, either the declare results or the recount votes task is undertaken.</t>
<t tx="sa.20080717192016.27">The Exclusive Choice pattern allows the thread of control to be directed to a specific (subsequent) task depending on the outcome of a preceding task, the values of elements of specific data elements in the process, the results of an expression evaluation or some other form of programmatic selection mechanism. The routing decision is made dynamically allowing it to be deferred to the latest possible moment at runtime.


</t>
</tnodes>
</leo_file>
